{"title":"Knight's Tour Adjacency Matrix Visual","markdown":{"yaml":{"title":"Knight's Tour Adjacency Matrix Visual","author":"Miles Libbey V","format":"html","image":"knightTourIcon.png","categories":["Self-Directed","R"]},"headingText":"generate_combinations(c(\"+\", \"-\"), c(1, 2))","containsRefs":false,"markdown":"\n\n```{r, \"Imports\", include=FALSE}\nlibrary(tidyverse)\nlibrary(Matrix)\nlibrary(purrr)\nlibrary(expm)\nlibrary(grid)\nlibrary(ggplot2)\nlibrary(stringr)\nlibrary(shiny)\nlibrary(rsconnect)\nlibrary(shinylive)\n\n'%notin%' <- Negate('%in%')\n```\n\n```{r, \"Custom Helper Functions\", include=FALSE}\ngenerate_combinations <- function(ops, nums) {\n  # Convert to numeric if character\n  nums <- as.numeric(nums)\n\n  # Generate all permutations of numbers\n  permute <- function(v) {\n    if (length(v) == 1) return(list(v))\n    out <- list()\n    for (i in seq_along(v)) {\n      rest <- v[-i]\n      for (p in permute(rest)) {\n        out <- append(out, list(c(v[i], p)))\n      }\n    }\n    return(out)\n  }\n\n  # Parse operations into functions\n  parse_op <- function(op_string) {\n    if (op_string == \"+\") {\n      return(function(x) x)\n    } else if (op_string == \"-\") {\n      return(function(x) -x)\n    } else if (grepl(\"^\\\\^\", op_string)) {\n      n <- as.numeric(sub(\"^\\\\^\", \"\", op_string))\n      return(function(x) x^n)\n    } else if (grepl(\"^/\", op_string)) {\n      n <- as.numeric(sub(\"^/\", \"\", op_string))\n      return(function(x) x / n)\n    } else {\n      stop(paste(\"Unknown operation:\", op_string))\n    }\n  }\n\n  # Convert all ops to functions\n  op_funcs <- lapply(ops, parse_op)\n\n  # Get all combinations of operations (each element gets an op)\n  op_combos <- expand.grid(rep(list(seq_along(op_funcs)), length(nums)))\n  \n  # Generate number permutations\n  num_perms <- permute(nums)\n\n  result <- list()\n\n  for (perm in num_perms) {\n    for (i in 1:nrow(op_combos)) {\n      indices <- as.integer(op_combos[i, ])\n      funcs <- op_funcs[indices]\n      transformed <- mapply(function(f, x) f(x), funcs, perm)\n      result <- append(result, list(transformed))\n    }\n  }\n\n  return(result)\n}\n\nmakeKnightMoves <- function(position, board_dims = c(8,8)) {\n  position <- as.numeric(position)\n  numRows <- board_dims[1]\n  numCols <- board_dims[2]\n  \n  ifValid <- function(placement) {\n    rowInBounds <- placement[1] >= 1 && placement[1] <= numRows\n    colInBounds <- placement[2] >= 1 && placement[2] <= numCols\n    return(rowInBounds && colInBounds)\n  }\n  \n  # Validate input\n  if (!ifValid(position)) {\n    stop(\"Please enter values within board dimensions\")\n  }\n\n  movesList <- lapply(generate_combinations(c(\"+\", \"-\"), c(1, 2)), function(a){\n    newPosition <- c(position[1] + a[1], position[2] + a[2])\n    if (ifValid(newPosition)) {\n      return(newPosition)\n    } else {\n      return(NULL)\n    }\n  })\n  \n  return(compact(movesList))\n}\n\nmakeKnightMoves(c(8,7), c(8,7))\n```\n\n```{r, \"Making Lattice Adjacency Matrix\", include=FALSE}\n#1\\space\\space\\space\\space 2\\space\\space\\space\\space3\\space\\space\\space\\space4\\\\\nmakeLatticeAdjMatrix <- function(numRow = 8, numCol = 8) {\n  cellTotal <- numRow * numCol\n  A <- matrix(0, nrow = cellTotal, ncol = cellTotal)\n  index_from_coords <- function(row, col) {\n    return((row - 1) * numCol + col)\n  }\n  \n  for (rowIndex in 1:numRow) {\n    for (colIndex in 1:numCol) {\n      from_index <- index_from_coords(rowIndex, colIndex)\n      moves <- makeKnightMoves(c(rowIndex, colIndex), board_dims = c(numRow, numCol))\n      for (move in moves) {\n        moveRow <- move[1]\n        moveCol <- move[2]\n        \n        if (moveRow <= numRow && moveCol <= numCol) { # if it's in the board\n          to_index <- index_from_coords(moveRow, moveCol)\n          A[from_index, to_index] <- 1\n          A[to_index, from_index] <- 1  # undirected\n        }\n      }\n    }\n  }\n  \n  # return(as(A, \"sparseMatrix\"))\n  return(A)\n}\n```\n\n```{r, \"Actual Plot\", include=FALSE}\nplotKnightFromMatrix <- function(position = c(1, 1), nrows = 8, ncols = 8, exponent = 1, showPathsToExponent = FALSE, probability = FALSE) {\n\n  if (length(position) != 2 || \n      !all(position >= 1) || \n      position[1] > nrows || \n      position[2] > ncols) {\n    stop(\"Position must be within the board dimensions\")\n  }\n  \n  A <- makeLatticeAdjMatrix(nrows, ncols)\n  \n  if(showPathsToExponent && exponent != 1) {\n    ATotal <- A\n    for (i in 2:exponent) {\n      ATotal <- ATotal + A %^% i\n      \n    }\n    A <- ATotal\n  } else {\n    A <- A %^% exponent # exponentiating\n  }\n\n  # Convert origin to matrix index\n  origin_index <- (position[1] - 1) * ncols + position[2]\n  path_counts <- A[origin_index, ]\n\n  # Map index → coordinates\n  grid <- expand.grid(x = 1:ncols, y = 1:nrows)\n  grid$index <- (grid$y - 1) * ncols + grid$x\n  grid$paths <- path_counts[grid$index]\n  \n  cutOff = 5\n  if (probability) {\n    grid <- grid %>%\n      mutate(totalPaths = sum(paths),\n             paths = paths / totalPaths)\n  }\n  grid <- grid %>%\n    mutate(numDigits = ifelse(str_detect(paths, \"^0\\\\.\"), \n                              nchar(paths) - 3,\n                              nchar(paths)),\n      pathsFormatted = ifelse(numDigits %notin% c(0:cutOff),\n                              format(signif(paths, 3), scientific = TRUE), \n                              paths))\n             \n  # Label the origin\n  grid$Type <- ifelse(grid$index == origin_index, \"Origin\", \"Other\")\n  origin_tile <- grid %>% filter(Type == \"Origin\")\n  \n  knightImage <- png::readPNG(\"knightImage.png\")\n  knightGrob <- rasterGrob(knightImage, interpolate = TRUE)\n\n  readable = 16\n  # Plot\n  ggplot(grid, aes(x = x, y = y, fill = paths)) +\n    geom_tile(color = \"grey60\") +\n    annotation_custom(\n      knightGrob,\n      xmin = origin_tile$x - 0.5,\n      xmax = origin_tile$x + 0.5,\n      ymin = origin_tile$y - 0.5,\n      ymax = origin_tile$y + 0.5\n    ) +\n    scale_fill_gradient(name = \"# of Paths\", low = \"white\", high = \"firebrick\", na.value = \"white\") +\n    scale_x_continuous(breaks = 1:ncols, minor_breaks = NULL) + \n    scale_y_continuous(breaks = 1:nrows, minor_breaks = NULL) + \n    geom_text(aes(label = ifelse(paths > 0, pathsFormatted, \"\")), \n              color = \"black\", \n              size = ifelse(grid$numDigits <= 3, \n                            5, \n                            ifelse(grid$numDigits > cutOff, \n                                   4, \n                                   4.5))\n              ) +\n    coord_fixed() +\n    labs(title = str_c(\"Possible Knight Moves after \", exponent,\" \", ifelse(exponent == 1, \"Jump\", \"Consecutive Jumps\"))) +\n    guides(fill = guide_colorbar(barwidth = 25, barheight = 3)) + \n    theme_minimal() +\n    theme(legend.position = \"bottom\",\n          axis.title = element_blank(),\n          axis.ticks.length = unit(0, \"pt\"),\n          axis.ticks = element_blank(),\n          panel.grid = element_blank(),\n          axis.text.x = element_text(size = 16, margin = margin(t = -5)),\n          axis.text.y = element_text(size = 16, margin = margin(r = -5)),\n          plot.title = element_text(size = readable+5, margin = margin(b = -10)),\n          legend.text = element_text(size = readable-1),\n          legend.title = element_text(size = readable+2)\n          )\n}\n# plotKnightFromMatrix(c(6,5), 8, 6, exponent = 1, showPathsToExponent = TRUE, probability = TRUE)\n```\n\nBelow you will find a Shiny App made for fun using concepts learned in *Linear Algebra* and *Computational Linear Algebra*, most notably graphs, adjacency matrices, matrix exponentiation. All of the concepts used to build the app are explained from an introductory level if you are interested in learning what is going on behind the scenes.\n\n## Shiny App\n\n```{r, \"Shiny App\"}\nui <- fluidPage(\n  sidebarLayout( # all of the input bars\n    sidebarPanel(\n      div(\n        style = \"font-size: 24px; font-weight: bold; margin-top: 0px;\",\n        textOutput(\"textBox\")\n      ),\n      sliderInput(\"exponent\", # id\n                  label = \"Choose # of Consecutive Jumps\",\n                  min = 1,\n                  max = 25,\n                  value = 1,\n                  step = 1),\n      sliderInput(\"rows\",\n                  label = \"# of Rows\",\n                  min = 2,\n                  max = 8,\n                  value = 8,\n                  step = 1),\n      sliderInput(\"cols\",\n                  label = \"# of Columns\",\n                  min = 2,\n                  max = 8,\n                  value = 8,\n                  step = 1),\n      radioButtons(\"showPaths\",\n                   label = \"Show Pathing Squares?\",\n                   choices = list(\"Yes\" = TRUE, \"No\" = FALSE),\n                   selected = TRUE),\n      radioButtons(\"mode\", # make probability of count\n                   label = \"Number Mode\",\n                   choices = list(\"Count\" = FALSE, \"Probability\" = TRUE),\n                   selected = FALSE)\n    ),\n    mainPanel(\n      plotOutput(\"knightPlot\", click = \"plot_click\", width = \"100%\")\n    )\n  )\n)\n\n# Server logic to receive inputs\nserver <- function(input, output, session) {\n  pos <- reactiveVal(c(5, 5))\n  text <- reactiveVal(\"Click any square to move the knight\")\n  \n  # === Reactive value to track last activity time ===\n  lastActivity <- reactiveVal(Sys.time())\n  \n  # === Track whether auto animation is active ===\n  autoAnimate <- reactiveVal(FALSE)\n  \n  # === Timestamp for programmatic changes to input$exponent ===\n  lastProgrammatic <- reactiveVal(NULL)  # store Sys.time() for programmatic updates\n  progIgnoreWindow <- 0.6                # seconds: window to treat exponent changes as programmatic\n  \n  # === Observe non-exponent inputs for activity (these are always user interactions) ===\n  observeEvent(\n    list(input$plot_click, input$rows, input$cols, input$showPaths, input$mode),\n    {\n      lastActivity(Sys.time())   # Reset activity\n      autoAnimate(FALSE)         # Stop auto animation immediately\n    }\n  )\n  \n  # === Observe exponent changes but ignore ones that are very close to our programmatic updates ===\n  observeEvent(input$exponent, {\n    lp <- lastProgrammatic()\n    if (!is.null(lp) && difftime(Sys.time(), lp, units = \"secs\") < progIgnoreWindow) {\n      # This change was likely caused by our code -> ignore for \"user activity\"\n      return()\n    }\n    # Otherwise treat as real user activity\n    lastActivity(Sys.time())\n    autoAnimate(FALSE)\n  })\n  \n  # === Check inactivity every 500ms and start autoAnimate when >= 5s of inactivity ===\n  observe({\n    invalidateLater(500, session)\n    isolate({\n      if (difftime(Sys.time(), lastActivity(), units = \"secs\") >= 5 && !autoAnimate()) {\n        autoAnimate(TRUE)\n        \n        # Immediately perform first increment and mark it programmatic so it won't count as activity\n        lastProgrammatic(Sys.time())\n        current <- isolate(input$exponent)\n        if (current < 25) {\n          updateSliderInput(session, \"exponent\", value = current + 1)\n        } else {\n          updateSliderInput(session, \"exponent\", value = 1)\n        }\n      }\n    })\n  })\n  \n  # === Increment exponent every 1.5 seconds while animating ===\n  observe({\n    req(autoAnimate())\n    invalidateLater(1500, session)  # 1.5 second between increments\n    \n    isolate({\n      # Before programmatic update, set timestamp so the activity observer ignores it\n      lastProgrammatic(Sys.time())\n      current <- input$exponent\n      if (current < 25) {\n        updateSliderInput(session, \"exponent\", value = current + 1)\n      } else {\n        updateSliderInput(session, \"exponent\", value = 1)\n      }\n    })\n  })\n  \n  # === Update knight position on click ===\n  observeEvent(input$plot_click, {\n    click <- input$plot_click\n    x <- max(min(round(click$x), input$cols), 1)\n    y <- max(min(round(click$y), input$rows), 1)\n    \n    pos(c(y, x))\n    text(\"\")\n  })\n  \n  # === Keep position within bounds ===\n  observeEvent(input$rows, {\n    current_pos <- pos()\n    if (current_pos[1] > input$rows) pos(c(input$rows, current_pos[2]))\n  })\n  \n  observeEvent(input$cols, {\n    current_pos <- pos()\n    if (current_pos[2] > input$cols) pos(c(current_pos[1], input$cols))\n  })\n  \n  # === Render plot and text ===\n  output$textBox <- renderText({ text() })\n  \n  output$knightPlot <- renderPlot({\n    plotKnightFromMatrix(position = pos(), \n                         nrows = input$rows, \n                         ncols = input$cols, \n                         exponent = input$exponent, \n                         showPathsToExponent = as.logical(input$showPaths),\n                         probability = as.logical(input$mode))\n  }, height = 650, width = 650)\n}\n\n# Run the application\nshinyApp(ui = ui, server = server)\n```\n\n\n## The Math Behind the App\n\n### Adjacency Matrices\n\nAn adjacency matrix is a type of matrix used to represent a mathematical graph, as pictured below:\n\n![](images/graphExample-01.png){.lightbox fig-align=\"center\" width=\"226\"}\n\nThe matrix shows which vertices are adjacent to one another and which are not. It can be thought of as this: rows are the starting points and the columns are the ending points. If you can get from a starting point to an ending point, then a 1 is placed, and a 0 is placed if not.\n\n$$\nA =\n\\begin{bmatrix}\n0 & 1 & 0 & 1 \\\\\n1 & 0 & 0 & 1 \\\\\n0 & 0 & 0 & 1 \\\\\n1 & 1 & 1 & 0 \\\\\n\\end{bmatrix}\n$$\n\nFor example, in our graph, 2 and 4 are connected, so if you look in the 2nd row (the starting place) and then look at the 4th row (the ending place), you will see that there is a 1. Vice versa, if you look at $A_{2,3}$ you will see that it is a 0, meaning 2 and 3 are unconnected, which can be confirmed from looking at the graph. These types of matrices are always square $n \\times n$ matrices because it just the same vertices being shown in the both and rows and columns. How this relates to a knight is if you imagine the 64 squares on a chess board as vertices, we can graph the connecting vertices to show what the knight can make in one move (later on we will be able to show multiple moves, but we are not there yet).\n\nHowever, chess squares have defined places where they are. In this graph, 1 can be put to the right of 4 and it wouldn't matter, as seen below.\n\n![There is not difference between this graph and the one before, it will have the same adjacency matrix](images/graphExample2-01.png){.lightbox fig-align=\"center\" width=\"324\"}\n\n### Lattice Adjacency Matrices\n\nWe need to introduce a system of order to the graph to make it more of a rigid grid. This is precisely why using a [Lattice graph](https://en.wikipedia.org/wiki/Lattice_graph) is so helpful in this case. Lattice graphs offer distinct coordinates, or lattices, which line up exactly with what we want to do with the chess squares because each squares is distinct and has 2-dimensional coordinates (i.e. the point (1,2) has an x dimension and a y dimension).\n\n$$\n\\begin{gather*}\n\\begin{bmatrix} \n(1,1) & (1,2) & (1,3) \\\\\n(2,1) & (2,2) & (2,3) \\\\\n(3,1) & (3,2) & (3,3) \\\\\n\\end{bmatrix} \\\\\n\\text{Lattice Matrix}\n\\end{gather*}\n$$\n\nJust as we made a adjacency matrix out of a normal graph, we can make a lattice adjacency matrix out of a lattice graph. For our purposes, lattice matrices are just regular matrices, but each entry in the matrix is representative of a lattice point (i.e. $A_{1,1} \\text{ is representative of the lattice point } (1,1)$).\n\nIn order to make a lattice adjacency matrix given $n \\times n$ lattices, we will essentially construct a $n^2 \\times n^2$ matrix. This comes from exactly what we did with the adjacency matrices; every single node was put across horizontally and vertically in order to have every pairs of connections between the nodes. Just in this case, since our grid has $n \\times n = n^2$ lattices, it will be much larger. Essentially what we're doing is making a long vector out of the lattice and then making that long vector 2D by taking the outer-product of 2 of long vectors.\n\n$$\n\\begin{gather*}\n  \\begin{bmatrix}\n  1 & 2 & 3 \\\\\n  4 & 5 & 6 \\\\\n  7 & 8 & 9 \\\\\n  \\end{bmatrix}\n  \\longrightarrow \n  \\begin{bmatrix}\n  1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ 6 \\\\ 7 \\\\ 8 \\\\ 9 \\\\ \\end{bmatrix} \n  \\longrightarrow\n  \\begin{bmatrix}\n  &1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\\\\n  1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ 6 \\\\ 7 \\\\ 8 \\\\ 9 \\\\\n  \\end{bmatrix} \\\\\n  \\space\\space\\text{Lattice}\\space\\space\\space\\space\\space\\space\\space\\text{Long Vector}\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\text{2D Long Vector}\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\n\\end{gather*}\n$$\n\n### Making the Lattice Adjacency Matrix\n\nNow that the matrix is made, we can use the 2D to 1D conversion formula: $(\\text{row} -1) \\times \\text{row length} + \\text{column}$. This helps streamline the process of actually assigning what squares are adjacent to one another when a knight jumps. For every single cell, we can just calculate the knight moves with a helper function and then assign them a 1 or 0 if they are adjacent.\n\nThe end result looks like this:\n\n```{r, \"Image\", echo=FALSE}\nimage(makeLatticeAdjMatrix())\n```\n\nNow, the reason why we wanted to go through all this trouble was because adjacency matrices are very useful for showing future movement from any starting point. This is done as easily as just exponentiating the adjacency matrix $A$ to some degree $n$. In doing so, from the basic properties of matrix multiplication, which we can see clearly using the matrix $A$ from before and making $A^2$ and zooming in on the results of node 2:\n\n$$\n\\begin{equation*}\n\\begin{gathered}\n  A =\n  \\begin{bmatrix}\n  0 & 1 & 0 & 1 \\\\\n  1 & 0 & 0 & 1 \\\\\n  0 & 0 & 0 & 1 \\\\\n  1 & 1 & 1 & 0 \\\\\n  \\end{bmatrix}\n  \\\\[1em]\n  A \\times A =\n  \\begin{bmatrix}\n  \\cdot & \\color{red}{(0 \\cdot 1) + (1 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(1 \\cdot 1) + (0 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(0 \\cdot 1) + (0 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(1 \\cdot 1) + (1 \\cdot 0) + (1 \\cdot 0) + (0 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\end{bmatrix}\n  =\n  \\begin{bmatrix}\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{2} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\end{bmatrix}\n  \\\\[1em]\n  \\begin{array}{c c l}\n    \\textbf{Start} & \\textbf{Count} & \\textbf{Explanation} \\\\\n    1 & 1 & \\text{1 path from node 1 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2: } (1 → 4 → 2) \\\\\n    2 & 2 & \\text{2 paths from node 2 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2: } (2 → 1 → 2), (2 → 4 → 2) \\\\\n    3 & 1 & \\text{1 path from node 3 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2: } (3 → 4 → 2) \\\\\n    4 & 1 & \\text{1 path from node 4 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2: } (4 → 1 → 2) \\\\\n    \\end{array}\n\\end{gathered}\n\\end{equation*}\n$$","srcMarkdownNoYaml":"\n\n```{r, \"Imports\", include=FALSE}\nlibrary(tidyverse)\nlibrary(Matrix)\nlibrary(purrr)\nlibrary(expm)\nlibrary(grid)\nlibrary(ggplot2)\nlibrary(stringr)\nlibrary(shiny)\nlibrary(rsconnect)\nlibrary(shinylive)\n\n'%notin%' <- Negate('%in%')\n```\n\n```{r, \"Custom Helper Functions\", include=FALSE}\ngenerate_combinations <- function(ops, nums) {\n  # Convert to numeric if character\n  nums <- as.numeric(nums)\n\n  # Generate all permutations of numbers\n  permute <- function(v) {\n    if (length(v) == 1) return(list(v))\n    out <- list()\n    for (i in seq_along(v)) {\n      rest <- v[-i]\n      for (p in permute(rest)) {\n        out <- append(out, list(c(v[i], p)))\n      }\n    }\n    return(out)\n  }\n\n  # Parse operations into functions\n  parse_op <- function(op_string) {\n    if (op_string == \"+\") {\n      return(function(x) x)\n    } else if (op_string == \"-\") {\n      return(function(x) -x)\n    } else if (grepl(\"^\\\\^\", op_string)) {\n      n <- as.numeric(sub(\"^\\\\^\", \"\", op_string))\n      return(function(x) x^n)\n    } else if (grepl(\"^/\", op_string)) {\n      n <- as.numeric(sub(\"^/\", \"\", op_string))\n      return(function(x) x / n)\n    } else {\n      stop(paste(\"Unknown operation:\", op_string))\n    }\n  }\n\n  # Convert all ops to functions\n  op_funcs <- lapply(ops, parse_op)\n\n  # Get all combinations of operations (each element gets an op)\n  op_combos <- expand.grid(rep(list(seq_along(op_funcs)), length(nums)))\n  \n  # Generate number permutations\n  num_perms <- permute(nums)\n\n  result <- list()\n\n  for (perm in num_perms) {\n    for (i in 1:nrow(op_combos)) {\n      indices <- as.integer(op_combos[i, ])\n      funcs <- op_funcs[indices]\n      transformed <- mapply(function(f, x) f(x), funcs, perm)\n      result <- append(result, list(transformed))\n    }\n  }\n\n  return(result)\n}\n\n# generate_combinations(c(\"+\", \"-\"), c(1, 2))\nmakeKnightMoves <- function(position, board_dims = c(8,8)) {\n  position <- as.numeric(position)\n  numRows <- board_dims[1]\n  numCols <- board_dims[2]\n  \n  ifValid <- function(placement) {\n    rowInBounds <- placement[1] >= 1 && placement[1] <= numRows\n    colInBounds <- placement[2] >= 1 && placement[2] <= numCols\n    return(rowInBounds && colInBounds)\n  }\n  \n  # Validate input\n  if (!ifValid(position)) {\n    stop(\"Please enter values within board dimensions\")\n  }\n\n  movesList <- lapply(generate_combinations(c(\"+\", \"-\"), c(1, 2)), function(a){\n    newPosition <- c(position[1] + a[1], position[2] + a[2])\n    if (ifValid(newPosition)) {\n      return(newPosition)\n    } else {\n      return(NULL)\n    }\n  })\n  \n  return(compact(movesList))\n}\n\nmakeKnightMoves(c(8,7), c(8,7))\n```\n\n```{r, \"Making Lattice Adjacency Matrix\", include=FALSE}\n#1\\space\\space\\space\\space 2\\space\\space\\space\\space3\\space\\space\\space\\space4\\\\\nmakeLatticeAdjMatrix <- function(numRow = 8, numCol = 8) {\n  cellTotal <- numRow * numCol\n  A <- matrix(0, nrow = cellTotal, ncol = cellTotal)\n  index_from_coords <- function(row, col) {\n    return((row - 1) * numCol + col)\n  }\n  \n  for (rowIndex in 1:numRow) {\n    for (colIndex in 1:numCol) {\n      from_index <- index_from_coords(rowIndex, colIndex)\n      moves <- makeKnightMoves(c(rowIndex, colIndex), board_dims = c(numRow, numCol))\n      for (move in moves) {\n        moveRow <- move[1]\n        moveCol <- move[2]\n        \n        if (moveRow <= numRow && moveCol <= numCol) { # if it's in the board\n          to_index <- index_from_coords(moveRow, moveCol)\n          A[from_index, to_index] <- 1\n          A[to_index, from_index] <- 1  # undirected\n        }\n      }\n    }\n  }\n  \n  # return(as(A, \"sparseMatrix\"))\n  return(A)\n}\n```\n\n```{r, \"Actual Plot\", include=FALSE}\nplotKnightFromMatrix <- function(position = c(1, 1), nrows = 8, ncols = 8, exponent = 1, showPathsToExponent = FALSE, probability = FALSE) {\n\n  if (length(position) != 2 || \n      !all(position >= 1) || \n      position[1] > nrows || \n      position[2] > ncols) {\n    stop(\"Position must be within the board dimensions\")\n  }\n  \n  A <- makeLatticeAdjMatrix(nrows, ncols)\n  \n  if(showPathsToExponent && exponent != 1) {\n    ATotal <- A\n    for (i in 2:exponent) {\n      ATotal <- ATotal + A %^% i\n      \n    }\n    A <- ATotal\n  } else {\n    A <- A %^% exponent # exponentiating\n  }\n\n  # Convert origin to matrix index\n  origin_index <- (position[1] - 1) * ncols + position[2]\n  path_counts <- A[origin_index, ]\n\n  # Map index → coordinates\n  grid <- expand.grid(x = 1:ncols, y = 1:nrows)\n  grid$index <- (grid$y - 1) * ncols + grid$x\n  grid$paths <- path_counts[grid$index]\n  \n  cutOff = 5\n  if (probability) {\n    grid <- grid %>%\n      mutate(totalPaths = sum(paths),\n             paths = paths / totalPaths)\n  }\n  grid <- grid %>%\n    mutate(numDigits = ifelse(str_detect(paths, \"^0\\\\.\"), \n                              nchar(paths) - 3,\n                              nchar(paths)),\n      pathsFormatted = ifelse(numDigits %notin% c(0:cutOff),\n                              format(signif(paths, 3), scientific = TRUE), \n                              paths))\n             \n  # Label the origin\n  grid$Type <- ifelse(grid$index == origin_index, \"Origin\", \"Other\")\n  origin_tile <- grid %>% filter(Type == \"Origin\")\n  \n  knightImage <- png::readPNG(\"knightImage.png\")\n  knightGrob <- rasterGrob(knightImage, interpolate = TRUE)\n\n  readable = 16\n  # Plot\n  ggplot(grid, aes(x = x, y = y, fill = paths)) +\n    geom_tile(color = \"grey60\") +\n    annotation_custom(\n      knightGrob,\n      xmin = origin_tile$x - 0.5,\n      xmax = origin_tile$x + 0.5,\n      ymin = origin_tile$y - 0.5,\n      ymax = origin_tile$y + 0.5\n    ) +\n    scale_fill_gradient(name = \"# of Paths\", low = \"white\", high = \"firebrick\", na.value = \"white\") +\n    scale_x_continuous(breaks = 1:ncols, minor_breaks = NULL) + \n    scale_y_continuous(breaks = 1:nrows, minor_breaks = NULL) + \n    geom_text(aes(label = ifelse(paths > 0, pathsFormatted, \"\")), \n              color = \"black\", \n              size = ifelse(grid$numDigits <= 3, \n                            5, \n                            ifelse(grid$numDigits > cutOff, \n                                   4, \n                                   4.5))\n              ) +\n    coord_fixed() +\n    labs(title = str_c(\"Possible Knight Moves after \", exponent,\" \", ifelse(exponent == 1, \"Jump\", \"Consecutive Jumps\"))) +\n    guides(fill = guide_colorbar(barwidth = 25, barheight = 3)) + \n    theme_minimal() +\n    theme(legend.position = \"bottom\",\n          axis.title = element_blank(),\n          axis.ticks.length = unit(0, \"pt\"),\n          axis.ticks = element_blank(),\n          panel.grid = element_blank(),\n          axis.text.x = element_text(size = 16, margin = margin(t = -5)),\n          axis.text.y = element_text(size = 16, margin = margin(r = -5)),\n          plot.title = element_text(size = readable+5, margin = margin(b = -10)),\n          legend.text = element_text(size = readable-1),\n          legend.title = element_text(size = readable+2)\n          )\n}\n# plotKnightFromMatrix(c(6,5), 8, 6, exponent = 1, showPathsToExponent = TRUE, probability = TRUE)\n```\n\nBelow you will find a Shiny App made for fun using concepts learned in *Linear Algebra* and *Computational Linear Algebra*, most notably graphs, adjacency matrices, matrix exponentiation. All of the concepts used to build the app are explained from an introductory level if you are interested in learning what is going on behind the scenes.\n\n## Shiny App\n\n```{r, \"Shiny App\"}\nui <- fluidPage(\n  sidebarLayout( # all of the input bars\n    sidebarPanel(\n      div(\n        style = \"font-size: 24px; font-weight: bold; margin-top: 0px;\",\n        textOutput(\"textBox\")\n      ),\n      sliderInput(\"exponent\", # id\n                  label = \"Choose # of Consecutive Jumps\",\n                  min = 1,\n                  max = 25,\n                  value = 1,\n                  step = 1),\n      sliderInput(\"rows\",\n                  label = \"# of Rows\",\n                  min = 2,\n                  max = 8,\n                  value = 8,\n                  step = 1),\n      sliderInput(\"cols\",\n                  label = \"# of Columns\",\n                  min = 2,\n                  max = 8,\n                  value = 8,\n                  step = 1),\n      radioButtons(\"showPaths\",\n                   label = \"Show Pathing Squares?\",\n                   choices = list(\"Yes\" = TRUE, \"No\" = FALSE),\n                   selected = TRUE),\n      radioButtons(\"mode\", # make probability of count\n                   label = \"Number Mode\",\n                   choices = list(\"Count\" = FALSE, \"Probability\" = TRUE),\n                   selected = FALSE)\n    ),\n    mainPanel(\n      plotOutput(\"knightPlot\", click = \"plot_click\", width = \"100%\")\n    )\n  )\n)\n\n# Server logic to receive inputs\nserver <- function(input, output, session) {\n  pos <- reactiveVal(c(5, 5))\n  text <- reactiveVal(\"Click any square to move the knight\")\n  \n  # === Reactive value to track last activity time ===\n  lastActivity <- reactiveVal(Sys.time())\n  \n  # === Track whether auto animation is active ===\n  autoAnimate <- reactiveVal(FALSE)\n  \n  # === Timestamp for programmatic changes to input$exponent ===\n  lastProgrammatic <- reactiveVal(NULL)  # store Sys.time() for programmatic updates\n  progIgnoreWindow <- 0.6                # seconds: window to treat exponent changes as programmatic\n  \n  # === Observe non-exponent inputs for activity (these are always user interactions) ===\n  observeEvent(\n    list(input$plot_click, input$rows, input$cols, input$showPaths, input$mode),\n    {\n      lastActivity(Sys.time())   # Reset activity\n      autoAnimate(FALSE)         # Stop auto animation immediately\n    }\n  )\n  \n  # === Observe exponent changes but ignore ones that are very close to our programmatic updates ===\n  observeEvent(input$exponent, {\n    lp <- lastProgrammatic()\n    if (!is.null(lp) && difftime(Sys.time(), lp, units = \"secs\") < progIgnoreWindow) {\n      # This change was likely caused by our code -> ignore for \"user activity\"\n      return()\n    }\n    # Otherwise treat as real user activity\n    lastActivity(Sys.time())\n    autoAnimate(FALSE)\n  })\n  \n  # === Check inactivity every 500ms and start autoAnimate when >= 5s of inactivity ===\n  observe({\n    invalidateLater(500, session)\n    isolate({\n      if (difftime(Sys.time(), lastActivity(), units = \"secs\") >= 5 && !autoAnimate()) {\n        autoAnimate(TRUE)\n        \n        # Immediately perform first increment and mark it programmatic so it won't count as activity\n        lastProgrammatic(Sys.time())\n        current <- isolate(input$exponent)\n        if (current < 25) {\n          updateSliderInput(session, \"exponent\", value = current + 1)\n        } else {\n          updateSliderInput(session, \"exponent\", value = 1)\n        }\n      }\n    })\n  })\n  \n  # === Increment exponent every 1.5 seconds while animating ===\n  observe({\n    req(autoAnimate())\n    invalidateLater(1500, session)  # 1.5 second between increments\n    \n    isolate({\n      # Before programmatic update, set timestamp so the activity observer ignores it\n      lastProgrammatic(Sys.time())\n      current <- input$exponent\n      if (current < 25) {\n        updateSliderInput(session, \"exponent\", value = current + 1)\n      } else {\n        updateSliderInput(session, \"exponent\", value = 1)\n      }\n    })\n  })\n  \n  # === Update knight position on click ===\n  observeEvent(input$plot_click, {\n    click <- input$plot_click\n    x <- max(min(round(click$x), input$cols), 1)\n    y <- max(min(round(click$y), input$rows), 1)\n    \n    pos(c(y, x))\n    text(\"\")\n  })\n  \n  # === Keep position within bounds ===\n  observeEvent(input$rows, {\n    current_pos <- pos()\n    if (current_pos[1] > input$rows) pos(c(input$rows, current_pos[2]))\n  })\n  \n  observeEvent(input$cols, {\n    current_pos <- pos()\n    if (current_pos[2] > input$cols) pos(c(current_pos[1], input$cols))\n  })\n  \n  # === Render plot and text ===\n  output$textBox <- renderText({ text() })\n  \n  output$knightPlot <- renderPlot({\n    plotKnightFromMatrix(position = pos(), \n                         nrows = input$rows, \n                         ncols = input$cols, \n                         exponent = input$exponent, \n                         showPathsToExponent = as.logical(input$showPaths),\n                         probability = as.logical(input$mode))\n  }, height = 650, width = 650)\n}\n\n# Run the application\nshinyApp(ui = ui, server = server)\n```\n\n\n## The Math Behind the App\n\n### Adjacency Matrices\n\nAn adjacency matrix is a type of matrix used to represent a mathematical graph, as pictured below:\n\n![](images/graphExample-01.png){.lightbox fig-align=\"center\" width=\"226\"}\n\nThe matrix shows which vertices are adjacent to one another and which are not. It can be thought of as this: rows are the starting points and the columns are the ending points. If you can get from a starting point to an ending point, then a 1 is placed, and a 0 is placed if not.\n\n$$\nA =\n\\begin{bmatrix}\n0 & 1 & 0 & 1 \\\\\n1 & 0 & 0 & 1 \\\\\n0 & 0 & 0 & 1 \\\\\n1 & 1 & 1 & 0 \\\\\n\\end{bmatrix}\n$$\n\nFor example, in our graph, 2 and 4 are connected, so if you look in the 2nd row (the starting place) and then look at the 4th row (the ending place), you will see that there is a 1. Vice versa, if you look at $A_{2,3}$ you will see that it is a 0, meaning 2 and 3 are unconnected, which can be confirmed from looking at the graph. These types of matrices are always square $n \\times n$ matrices because it just the same vertices being shown in the both and rows and columns. How this relates to a knight is if you imagine the 64 squares on a chess board as vertices, we can graph the connecting vertices to show what the knight can make in one move (later on we will be able to show multiple moves, but we are not there yet).\n\nHowever, chess squares have defined places where they are. In this graph, 1 can be put to the right of 4 and it wouldn't matter, as seen below.\n\n![There is not difference between this graph and the one before, it will have the same adjacency matrix](images/graphExample2-01.png){.lightbox fig-align=\"center\" width=\"324\"}\n\n### Lattice Adjacency Matrices\n\nWe need to introduce a system of order to the graph to make it more of a rigid grid. This is precisely why using a [Lattice graph](https://en.wikipedia.org/wiki/Lattice_graph) is so helpful in this case. Lattice graphs offer distinct coordinates, or lattices, which line up exactly with what we want to do with the chess squares because each squares is distinct and has 2-dimensional coordinates (i.e. the point (1,2) has an x dimension and a y dimension).\n\n$$\n\\begin{gather*}\n\\begin{bmatrix} \n(1,1) & (1,2) & (1,3) \\\\\n(2,1) & (2,2) & (2,3) \\\\\n(3,1) & (3,2) & (3,3) \\\\\n\\end{bmatrix} \\\\\n\\text{Lattice Matrix}\n\\end{gather*}\n$$\n\nJust as we made a adjacency matrix out of a normal graph, we can make a lattice adjacency matrix out of a lattice graph. For our purposes, lattice matrices are just regular matrices, but each entry in the matrix is representative of a lattice point (i.e. $A_{1,1} \\text{ is representative of the lattice point } (1,1)$).\n\nIn order to make a lattice adjacency matrix given $n \\times n$ lattices, we will essentially construct a $n^2 \\times n^2$ matrix. This comes from exactly what we did with the adjacency matrices; every single node was put across horizontally and vertically in order to have every pairs of connections between the nodes. Just in this case, since our grid has $n \\times n = n^2$ lattices, it will be much larger. Essentially what we're doing is making a long vector out of the lattice and then making that long vector 2D by taking the outer-product of 2 of long vectors.\n\n$$\n\\begin{gather*}\n  \\begin{bmatrix}\n  1 & 2 & 3 \\\\\n  4 & 5 & 6 \\\\\n  7 & 8 & 9 \\\\\n  \\end{bmatrix}\n  \\longrightarrow \n  \\begin{bmatrix}\n  1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ 6 \\\\ 7 \\\\ 8 \\\\ 9 \\\\ \\end{bmatrix} \n  \\longrightarrow\n  \\begin{bmatrix}\n  &1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\\\\n  1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ 6 \\\\ 7 \\\\ 8 \\\\ 9 \\\\\n  \\end{bmatrix} \\\\\n  \\space\\space\\text{Lattice}\\space\\space\\space\\space\\space\\space\\space\\text{Long Vector}\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\text{2D Long Vector}\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\n\\end{gather*}\n$$\n\n### Making the Lattice Adjacency Matrix\n\nNow that the matrix is made, we can use the 2D to 1D conversion formula: $(\\text{row} -1) \\times \\text{row length} + \\text{column}$. This helps streamline the process of actually assigning what squares are adjacent to one another when a knight jumps. For every single cell, we can just calculate the knight moves with a helper function and then assign them a 1 or 0 if they are adjacent.\n\nThe end result looks like this:\n\n```{r, \"Image\", echo=FALSE}\nimage(makeLatticeAdjMatrix())\n```\n\nNow, the reason why we wanted to go through all this trouble was because adjacency matrices are very useful for showing future movement from any starting point. This is done as easily as just exponentiating the adjacency matrix $A$ to some degree $n$. In doing so, from the basic properties of matrix multiplication, which we can see clearly using the matrix $A$ from before and making $A^2$ and zooming in on the results of node 2:\n\n$$\n\\begin{equation*}\n\\begin{gathered}\n  A =\n  \\begin{bmatrix}\n  0 & 1 & 0 & 1 \\\\\n  1 & 0 & 0 & 1 \\\\\n  0 & 0 & 0 & 1 \\\\\n  1 & 1 & 1 & 0 \\\\\n  \\end{bmatrix}\n  \\\\[1em]\n  A \\times A =\n  \\begin{bmatrix}\n  \\cdot & \\color{red}{(0 \\cdot 1) + (1 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(1 \\cdot 1) + (0 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(0 \\cdot 1) + (0 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(1 \\cdot 1) + (1 \\cdot 0) + (1 \\cdot 0) + (0 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\end{bmatrix}\n  =\n  \\begin{bmatrix}\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{2} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\end{bmatrix}\n  \\\\[1em]\n  \\begin{array}{c c l}\n    \\textbf{Start} & \\textbf{Count} & \\textbf{Explanation} \\\\\n    1 & 1 & \\text{1 path from node 1 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2: } (1 → 4 → 2) \\\\\n    2 & 2 & \\text{2 paths from node 2 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2: } (2 → 1 → 2), (2 → 4 → 2) \\\\\n    3 & 1 & \\text{1 path from node 3 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2: } (3 → 4 → 2) \\\\\n    4 & 1 & \\text{1 path from node 4 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2: } (4 → 1 → 2) \\\\\n    \\end{array}\n\\end{gathered}\n\\end{equation*}\n$$"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","resources":["../../Miles_LibbeyV_Resume_2025.pdf"],"editor":"source","theme":"cosmo","page-footer":{"left":"&copy; [name], 2025<br>\nAll content licensed under <i class='bi-badge-cc'></i>\n[(CC BY-NC-SA 4.0)](http://creativecommons.org/licenses/by-nc-sa/4.0/)\n","right":"Site built with <a href='https://quarto.org/'>Quarto</a>\n"},"title":"Knight's Tour Adjacency Matrix Visual","author":"Miles Libbey V","image":"knightTourIcon.png","categories":["Self-Directed","R"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}