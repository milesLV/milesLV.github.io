{"title":"Knight's Tour Adjacency Matrix Visual","markdown":{"yaml":{"title":"Knight's Tour Adjacency Matrix Visual","author":"Miles Libbey V","format":"html","image":"icon.png","categories":["Self-Directed","R"],"crossref":{"custom":[{"kind":"float","key":"suppfig","latex-env":"suppfig","reference-prefix":"Fig.","space-before-numbering":true,"latex-list-of-description":"Supplementary Figure"}]}},"headingText":"generate_combinations(c(\"+\", \"-\"), c(1, 2))","containsRefs":false,"markdown":"\n\n```{r, \"Imports\", include=FALSE}\nlibrary(dplyr)\nlibrary(Matrix)\nlibrary(grid)\nlibrary(ggplot2)\nlibrary(shiny)\n\n'%notin%' <- Negate('%in%')\n```\n\n```{r, \"Custom Helper Functions\", include=FALSE}\ngenerate_combinations <- function(ops, nums) {\n  # Convert to numeric if character\n  nums <- as.numeric(nums)\n\n  # Generate all permutations of numbers\n  permute <- function(v) {\n    if (length(v) == 1) return(list(v))\n    out <- list()\n    for (i in seq_along(v)) {\n      rest <- v[-i]\n      for (p in permute(rest)) {\n        out <- append(out, list(c(v[i], p)))\n      }\n    }\n    return(out)\n  }\n\n  # Parse operations into functions\n  parse_op <- function(op_string) {\n    if (op_string == \"+\") {\n      return(function(x) x)\n    } else if (op_string == \"-\") {\n      return(function(x) -x)\n    } else if (grepl(\"^\\\\^\", op_string)) {\n      n <- as.numeric(sub(\"^\\\\^\", \"\", op_string))\n      return(function(x) x^n)\n    } else if (grepl(\"^/\", op_string)) {\n      n <- as.numeric(sub(\"^/\", \"\", op_string))\n      return(function(x) x / n)\n    } else {\n      stop(paste(\"Unknown operation:\", op_string))\n    }\n  }\n\n  # Convert all ops to functions\n  op_funcs <- lapply(ops, parse_op)\n\n  # Get all combinations of operations (each element gets an op)\n  op_combos <- expand.grid(rep(list(seq_along(op_funcs)), length(nums)))\n  \n  # Generate number permutations\n  num_perms <- permute(nums)\n\n  result <- list()\n\n  for (perm in num_perms) {\n    for (i in 1:nrow(op_combos)) {\n      indices <- as.integer(op_combos[i, ])\n      funcs <- op_funcs[indices]\n      transformed <- mapply(function(f, x) f(x), funcs, perm)\n      result <- append(result, list(transformed))\n    }\n  }\n\n  return(result)\n}\n\nmakeKnightMoves <- function(position, board_dims = c(8,8)) {\n  position <- as.numeric(position)\n  numRows <- board_dims[1]\n  numCols <- board_dims[2]\n  \n  ifValid <- function(placement) {\n    rowInBounds <- placement[1] >= 1 && placement[1] <= numRows\n    colInBounds <- placement[2] >= 1 && placement[2] <= numCols\n    return(rowInBounds && colInBounds)\n  }\n  \n  # Validate input\n  if (!ifValid(position)) {\n    stop(\"Please enter values within board dimensions\")\n  }\n\n  movesList <- lapply(generate_combinations(c(\"+\", \"-\"), c(1, 2)), function(a){\n    newPosition <- c(position[1] + a[1], position[2] + a[2])\n    if (ifValid(newPosition)) {\n      return(newPosition)\n    } else {\n      return(invisible())\n    }\n  })\n  movesList[sapply(movesList, is.null)] <- NULL\n  return(movesList)\n}\n\nmakeKnightMoves(c(8,7), c(8,7))\n\nmatrix_power <- function(A, n) {\n  # Check input\n  if (!is.matrix(A) || ncol(A) != nrow(A)) {\n    stop(\"A must be a square matrix\")\n  }\n  if (!is.numeric(n) || length(n) != 1 || floor(n) != n) {\n    stop(\"Exponent n must be a single integer\")\n  }\n  \n  # Handle special cases\n  if (n == 0) return(diag(nrow(A)))\n  if (n < 0) {\n    A <- solve(A)   # Invert for negative powers\n    n <- -n\n  }\n  \n  # Exponentiation by squaring\n  result <- diag(nrow(A))   # identity\n  base <- A\n  while (n > 0) {\n    if (n %% 2 == 1) {\n      result <- result %*% base\n    }\n    base <- base %*% base\n    n <- n %/% 2\n  }\n  result\n}\n```\n\n```{r, \"Making Lattice Adjacency Matrix\", include=FALSE}\nmakeLatticeAdjMatrix <- function(numRow = 8, numCol = 8) {\n  cellTotal <- numRow * numCol\n  A <- matrix(0, nrow = cellTotal, ncol = cellTotal)\n  index_from_coords <- function(row, col) {\n    return((row - 1) * numCol + col)\n  }\n  \n  for (rowIndex in 1:numRow) {\n    for (colIndex in 1:numCol) {\n      from_index <- index_from_coords(rowIndex, colIndex)\n      moves <- makeKnightMoves(c(rowIndex, colIndex), board_dims = c(numRow, numCol))\n      for (move in moves) {\n        moveRow <- move[1]\n        moveCol <- move[2]\n        \n        if(moveRow <= numRow && moveCol <= numCol) { # if it's in the board dimensions\n          to_index <- index_from_coords(moveRow, moveCol)\n          A[from_index, to_index] <- 1\n          A[to_index, from_index] <- 1  # undirected\n        }\n      }\n    }\n  }\n  \n  return(A)\n}\n```\n\nBelow you will find a Shiny App made for fun using concepts learned in *Linear Algebra* and *Computational Linear Algebra*, most notably graphs, adjacency matrices, matrix exponentiation, and Markov chains. All of the key concepts used to build the app are explained if you are interested in learning what is going on behind the scenes.\n\n## Shiny App\n\n<iframe src=\"https://mileslv.github.io/KnightsTourShinyApp/\" width=\"100%\" height=\"700\">\n\n</iframe>\n\n## The Math Behind the App\n\n### Adjacency Matrices {#adjacency-matrices}\n\nAn adjacency matrix is a type of matrix used to represent a mathematical graph, as pictured below:\n\n::: {#suppfig-custom}\n![](images/graphExample.png){fig-align=\"center\" width=\"226\"}\n:::\n\nThe matrix shows which vertices in a graph are adjacent to one another and which are not. It can be thought of as this: the rows are the starting points and the columns are the ending points. If you can get from a starting point to an ending point, then a 1 is placed, and otherwise it is 0.\n\n$$\nA =\n\\begin{bmatrix}\n0 & 1 & 0 & 1 \\\\\n1 & 0 & 0 & 1 \\\\\n0 & 0 & 0 & 1 \\\\\n1 & 1 & 1 & 0 \\\\\n\\end{bmatrix}\n$$\n\nFor example, in our graph, 2 and 4 are connected. If you look in the 2nd row (the starting place) and then at the 4th column (the ending place), you will see that there is a 1. Conversely, if you look at $A_{2,3}$, you will see that it is 0, meaning 2 and 3 are unconnected, which can be confirmed by looking at the graph. These types of matrices are always square $n \\times n$ matrices because the same vertices are shown in both the rows and the columns. How this relates to a knight is as follows: if you imagine the 64 squares on a chessboard as vertices, we can graph the connecting vertices to show what the knight can reach in one move (later on, we will extend this to multiple moves, but we are not there yet).\n\nHowever, chess squares have fixed positions. In this graph, 1 could be placed to the right of 4 and it would not matter, as seen below.\n\n![Fig. 2: There is no difference between this graph and the one before, it will have the same adjacency matrix](images/graphExample2.png){fig-align=\"center\" width=\"324\"}\n\n### Lattice Adjacency Matrices\n\nWe need to introduce a system of order to the graph to make it more of a rigid grid. This is precisely why using a [Lattice graph](https://en.wikipedia.org/wiki/Lattice_graph) is so helpful in this case. Lattice graphs offer distinct coordinates, or lattices, which line up exactly with what we want to do with the chess squares because each square is distinct and has 2-dimensional coordinates (i.e. the square (1, 2) has an x dimension and a y dimension).\n\n$$\n\\begin{gather*}\n\\begin{bmatrix} \n(1,1) & (1,2) & (1,3) \\\\\n(2,1) & (2,2) & (2,3) \\\\\n(3,1) & (3,2) & (3,3) \\\\\n\\end{bmatrix} \\\\\n\\text{Lattice Matrix}\n\\end{gather*}\n$$\n\nJust as we made an adjacency matrix from a normal graph, we can make a lattice adjacency matrix from a lattice graph. For our purposes, lattice matrices are just regular matrices, but each entry in the matrix represents a lattice point (i.e., $A_{1,1}$ represents the lattice point $(1,1)$).\n\nIn order to make a lattice adjacency matrix given $n \\times n$ lattices, we will essentially construct an $n^2 \\times n^2$ matrix. This comes directly from what we did with the adjacency matrices; every single node was placed both horizontally and vertically in order to show every pair of connections between the nodes. In this case, since our grid has $n \\times n = n^2$ lattices, the matrix will be much larger. Essentially, what we are doing is making a long vector out of the lattice and then making that long vector 2D by taking the outer product of two long vectors.\n\n$$\n\\begin{gather*}\n  \\begin{bmatrix}\n  \\textcolor{red}{1} & \\textcolor{red}{2} & \\textcolor{red}{3} \\\\\n  \\textcolor{blue}{4} & \\textcolor{blue}{5} & \\textcolor{blue}{6} \\\\\n  \\textcolor{green}{7} & \\textcolor{green}{8} & \\textcolor{green}{9} \\\\\n  \\end{bmatrix}\n  \\longrightarrow \n  \\begin{bmatrix}\n  \\textcolor{red}{1} \\\\ \\textcolor{red}{2} \\\\ \\textcolor{red}{3} \\\\ \\textcolor{blue}{4} \\\\ \\textcolor{blue}{5} \\\\ \\textcolor{blue}{6} \\\\ \\textcolor{green}{7} \\\\ \\textcolor{green}{8} \\\\ \\textcolor{green}{9} \\\\ \\end{bmatrix} \n  \\longrightarrow\n\\begin{bmatrix}  1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ 6 \\\\ 7 \\\\ 8 \\\\ 9 \\\\ \\end{bmatrix} \n\\begin{bmatrix} 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\end{bmatrix}\n  \\longrightarrow\n  \\begin{bmatrix}\n  &1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\\\\n  1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ 6 \\\\ 7 \\\\ 8 \\\\ 9 \\\\\n  \\end{bmatrix} \\\\\n  \\space\\space\\text{Lattice}\\space\\space\\space\\space\\space\\space\\space\\text{Long Vector}\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\text{Outer Product}\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\text{2D Long Vector}\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\n\\end{gather*}\n$$\n\n### Making the Lattice Adjacency Matrix\n\nNow that the matrix is made, we can use the 2D to 1D conversion formula: $(\\text{row} -1) \\times \\text{row length} + \\text{column}$. This helps streamline the process of actually assigning what squares are adjacent to one another when a knight jumps. For every single cell, we can just calculate the knight moves with a helper function and then assign them a 1 or 0 if they are adjacent.\n\nThe end result looks like this:\n\n```{r, \"Image\", echo=FALSE}\nimage(makeLatticeAdjMatrix())\n```\n\nNow, the reason why we wanted to go through all this trouble was because adjacency matrices are very useful for showing future movement from any starting point. This is done as easily as just exponentiating the adjacency matrix $A$ to some degree $n$. In doing so, from the basic properties of matrix multiplication, we can determine all of the possible paths of length $n$ that start and end anywhere. For example, by taking the matrix $A$ from before (representative of [Graph -@suppfig-custom].), computing $A^2$, and zooming in on the results for the paths that end at node 2 after 2 walks, we can see this clearly:\n\n$$\n\\begin{equation*}\n\\begin{gathered}\n  A =\n  \\begin{bmatrix}\n  0 & 1 & 0 & 1 \\\\\n  1 & 0 & 0 & 1 \\\\\n  0 & 0 & 0 & 1 \\\\\n  1 & 1 & 1 & 0 \\\\\n  \\end{bmatrix}\n  \\\\[1em]\n  A \\times A =\n  \\begin{bmatrix}\n  \\cdot & \\color{red}{(0 \\cdot 1) + (1 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(1 \\cdot 1) + (0 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(0 \\cdot 1) + (0 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(1 \\cdot 1) + (1 \\cdot 0) + (1 \\cdot 0) + (0 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\end{bmatrix}\n  =\n  \\begin{bmatrix}\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{2} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\end{bmatrix}\n  \\\\[1em]\n  \\begin{array}{c c l}\n    \\textbf{Start} & \\textbf{Count} & \\textbf{Explanation} \\\\\n    1 & 1 & \\text{1 path from node 1 of } \\textcolor{red}{\\text{length }\\textbf{2}} \\text{ to node 2} \\\\\n    2 & 2 & \\text{2 paths from node 2 of } \\textcolor{blue}{\\text{length }\\textbf{2}} \\text{ to node 2}\\\\\n    3 & 1 & \\text{1 path from node 3 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2}\\\\\n    4 & 1 & \\text{1 path from node 4 of } \\textcolor{purple}{\\text{length }\\textbf{2}} \\text{ to node 2}\\\\\n    \\end{array}\n\\end{gathered}\n\\end{equation*}\n$$\n\n![Fig. 3: All of the paths extending to node 2 with 2 edges, as representative of col. 2 of $A^2$](images/graphExample3.png){.lightbox fig-align=\"center\" width=\"300\"}\n\nHere it can clearly be seen that, just as before, when we look at the column 2, we find all of the nodes that have a connection with node 2, but this time it is if they have a path of 2 walks (from raising $A$ to $n = 2$). This allows for there to be more numbers than just 0 and 1 as it's possible that nodes have 2 ways to get to node 2 in 2 moves, just like in the case of node 2.\n\nAnd there is no limit on how high the exponent can go-- meaning that if it weren't for computation time or the bigger inhibitor of digit space, the shiny app can display thousands of moves into the future.\n\n### What It All Means\n\nWhile this project may not be the most practical application, the patterns that emerge in the app highlight broadly useful concepts from linear algebra. If you interact with the app long enough, you will notice that certain squares — particularly the central squares — consistently have the highest count or probability of the knight landing on them. This behavior mirrors the idea of eigenvalues in a matrix, which predict long-term behavior: in this case, how the tiles' 'popularity' evolves after multiple moves. Eigenvalues essentially tell us the dominant patterns of movement that emerge after many iterations, with higher eigenvalues corresponding to squares that are more likely to be landed on.\n\nIn some setups, there is a switch between light squares dominating or dark squares dominating depending on whether the exponent is odd or even. This is a result of the bipartite nature of the board: the board can be divided into two distinct sets of squares (light and dark), and squares within each set are not connected to others of the same set. This property is crucial because it suggests that the eigenvalues of the matrix governing the knight’s movement are symmetric around zero. Specifically, for matrices with this symmetry, we have $\\lambda \\times m = -\\lambda \\times m$, which explains why odd and even powers of the matrix lead to such different behaviors. The switch between the odd and even powers of the matrix helps to explain the shifting dominance of the squares. When we raise the matrix to odd powers, the behavior tends to favor one set (either light or dark squares), while raising it to even powers leads to a more balanced or alternating pattern, as the symmetry of the eigenvalues becomes more apparent.\n\nAdjacency matrices can be very powerful tools, helping with topics such as the [spread of infectious disease](https://arxiv.org/abs/2207.02737), [Google's PageRank](https://math.libretexts.org/Bookshelves/Linear_Algebra/Understanding_Linear_Algebra_(Austin)/04%3A_Eigenvalues_and_eigenvectors/4.05%3A_Markov_chains_and_Google's_PageRank_algorithm), and [weather forecast](https://www.researchgate.net/publication/350840280_Applications_of_Markov_Chain_in_Forecast).\n\n# References\n\nBrualdi, Richard. “The Mutually Beneficial Relationship of Graphs and Matrices.” CBMS Regional Conference Series in Mathematics, vol. 115, no. 1, 6 July 2011, pp. 14–23, [www.ams.org/bookstore/pspdf/cbms-115-prev.pdf](www.ams.org/bookstore/pspdf/cbms-115-prev.pdf), <https://doi.org/10.1090/cbms/115>. Accessed 9 Sept. 2025.\n","srcMarkdownNoYaml":"\n\n```{r, \"Imports\", include=FALSE}\nlibrary(dplyr)\nlibrary(Matrix)\nlibrary(grid)\nlibrary(ggplot2)\nlibrary(shiny)\n\n'%notin%' <- Negate('%in%')\n```\n\n```{r, \"Custom Helper Functions\", include=FALSE}\ngenerate_combinations <- function(ops, nums) {\n  # Convert to numeric if character\n  nums <- as.numeric(nums)\n\n  # Generate all permutations of numbers\n  permute <- function(v) {\n    if (length(v) == 1) return(list(v))\n    out <- list()\n    for (i in seq_along(v)) {\n      rest <- v[-i]\n      for (p in permute(rest)) {\n        out <- append(out, list(c(v[i], p)))\n      }\n    }\n    return(out)\n  }\n\n  # Parse operations into functions\n  parse_op <- function(op_string) {\n    if (op_string == \"+\") {\n      return(function(x) x)\n    } else if (op_string == \"-\") {\n      return(function(x) -x)\n    } else if (grepl(\"^\\\\^\", op_string)) {\n      n <- as.numeric(sub(\"^\\\\^\", \"\", op_string))\n      return(function(x) x^n)\n    } else if (grepl(\"^/\", op_string)) {\n      n <- as.numeric(sub(\"^/\", \"\", op_string))\n      return(function(x) x / n)\n    } else {\n      stop(paste(\"Unknown operation:\", op_string))\n    }\n  }\n\n  # Convert all ops to functions\n  op_funcs <- lapply(ops, parse_op)\n\n  # Get all combinations of operations (each element gets an op)\n  op_combos <- expand.grid(rep(list(seq_along(op_funcs)), length(nums)))\n  \n  # Generate number permutations\n  num_perms <- permute(nums)\n\n  result <- list()\n\n  for (perm in num_perms) {\n    for (i in 1:nrow(op_combos)) {\n      indices <- as.integer(op_combos[i, ])\n      funcs <- op_funcs[indices]\n      transformed <- mapply(function(f, x) f(x), funcs, perm)\n      result <- append(result, list(transformed))\n    }\n  }\n\n  return(result)\n}\n\n# generate_combinations(c(\"+\", \"-\"), c(1, 2))\nmakeKnightMoves <- function(position, board_dims = c(8,8)) {\n  position <- as.numeric(position)\n  numRows <- board_dims[1]\n  numCols <- board_dims[2]\n  \n  ifValid <- function(placement) {\n    rowInBounds <- placement[1] >= 1 && placement[1] <= numRows\n    colInBounds <- placement[2] >= 1 && placement[2] <= numCols\n    return(rowInBounds && colInBounds)\n  }\n  \n  # Validate input\n  if (!ifValid(position)) {\n    stop(\"Please enter values within board dimensions\")\n  }\n\n  movesList <- lapply(generate_combinations(c(\"+\", \"-\"), c(1, 2)), function(a){\n    newPosition <- c(position[1] + a[1], position[2] + a[2])\n    if (ifValid(newPosition)) {\n      return(newPosition)\n    } else {\n      return(invisible())\n    }\n  })\n  movesList[sapply(movesList, is.null)] <- NULL\n  return(movesList)\n}\n\nmakeKnightMoves(c(8,7), c(8,7))\n\nmatrix_power <- function(A, n) {\n  # Check input\n  if (!is.matrix(A) || ncol(A) != nrow(A)) {\n    stop(\"A must be a square matrix\")\n  }\n  if (!is.numeric(n) || length(n) != 1 || floor(n) != n) {\n    stop(\"Exponent n must be a single integer\")\n  }\n  \n  # Handle special cases\n  if (n == 0) return(diag(nrow(A)))\n  if (n < 0) {\n    A <- solve(A)   # Invert for negative powers\n    n <- -n\n  }\n  \n  # Exponentiation by squaring\n  result <- diag(nrow(A))   # identity\n  base <- A\n  while (n > 0) {\n    if (n %% 2 == 1) {\n      result <- result %*% base\n    }\n    base <- base %*% base\n    n <- n %/% 2\n  }\n  result\n}\n```\n\n```{r, \"Making Lattice Adjacency Matrix\", include=FALSE}\nmakeLatticeAdjMatrix <- function(numRow = 8, numCol = 8) {\n  cellTotal <- numRow * numCol\n  A <- matrix(0, nrow = cellTotal, ncol = cellTotal)\n  index_from_coords <- function(row, col) {\n    return((row - 1) * numCol + col)\n  }\n  \n  for (rowIndex in 1:numRow) {\n    for (colIndex in 1:numCol) {\n      from_index <- index_from_coords(rowIndex, colIndex)\n      moves <- makeKnightMoves(c(rowIndex, colIndex), board_dims = c(numRow, numCol))\n      for (move in moves) {\n        moveRow <- move[1]\n        moveCol <- move[2]\n        \n        if(moveRow <= numRow && moveCol <= numCol) { # if it's in the board dimensions\n          to_index <- index_from_coords(moveRow, moveCol)\n          A[from_index, to_index] <- 1\n          A[to_index, from_index] <- 1  # undirected\n        }\n      }\n    }\n  }\n  \n  return(A)\n}\n```\n\nBelow you will find a Shiny App made for fun using concepts learned in *Linear Algebra* and *Computational Linear Algebra*, most notably graphs, adjacency matrices, matrix exponentiation, and Markov chains. All of the key concepts used to build the app are explained if you are interested in learning what is going on behind the scenes.\n\n## Shiny App\n\n<iframe src=\"https://mileslv.github.io/KnightsTourShinyApp/\" width=\"100%\" height=\"700\">\n\n</iframe>\n\n## The Math Behind the App\n\n### Adjacency Matrices {#adjacency-matrices}\n\nAn adjacency matrix is a type of matrix used to represent a mathematical graph, as pictured below:\n\n::: {#suppfig-custom}\n![](images/graphExample.png){fig-align=\"center\" width=\"226\"}\n:::\n\nThe matrix shows which vertices in a graph are adjacent to one another and which are not. It can be thought of as this: the rows are the starting points and the columns are the ending points. If you can get from a starting point to an ending point, then a 1 is placed, and otherwise it is 0.\n\n$$\nA =\n\\begin{bmatrix}\n0 & 1 & 0 & 1 \\\\\n1 & 0 & 0 & 1 \\\\\n0 & 0 & 0 & 1 \\\\\n1 & 1 & 1 & 0 \\\\\n\\end{bmatrix}\n$$\n\nFor example, in our graph, 2 and 4 are connected. If you look in the 2nd row (the starting place) and then at the 4th column (the ending place), you will see that there is a 1. Conversely, if you look at $A_{2,3}$, you will see that it is 0, meaning 2 and 3 are unconnected, which can be confirmed by looking at the graph. These types of matrices are always square $n \\times n$ matrices because the same vertices are shown in both the rows and the columns. How this relates to a knight is as follows: if you imagine the 64 squares on a chessboard as vertices, we can graph the connecting vertices to show what the knight can reach in one move (later on, we will extend this to multiple moves, but we are not there yet).\n\nHowever, chess squares have fixed positions. In this graph, 1 could be placed to the right of 4 and it would not matter, as seen below.\n\n![Fig. 2: There is no difference between this graph and the one before, it will have the same adjacency matrix](images/graphExample2.png){fig-align=\"center\" width=\"324\"}\n\n### Lattice Adjacency Matrices\n\nWe need to introduce a system of order to the graph to make it more of a rigid grid. This is precisely why using a [Lattice graph](https://en.wikipedia.org/wiki/Lattice_graph) is so helpful in this case. Lattice graphs offer distinct coordinates, or lattices, which line up exactly with what we want to do with the chess squares because each square is distinct and has 2-dimensional coordinates (i.e. the square (1, 2) has an x dimension and a y dimension).\n\n$$\n\\begin{gather*}\n\\begin{bmatrix} \n(1,1) & (1,2) & (1,3) \\\\\n(2,1) & (2,2) & (2,3) \\\\\n(3,1) & (3,2) & (3,3) \\\\\n\\end{bmatrix} \\\\\n\\text{Lattice Matrix}\n\\end{gather*}\n$$\n\nJust as we made an adjacency matrix from a normal graph, we can make a lattice adjacency matrix from a lattice graph. For our purposes, lattice matrices are just regular matrices, but each entry in the matrix represents a lattice point (i.e., $A_{1,1}$ represents the lattice point $(1,1)$).\n\nIn order to make a lattice adjacency matrix given $n \\times n$ lattices, we will essentially construct an $n^2 \\times n^2$ matrix. This comes directly from what we did with the adjacency matrices; every single node was placed both horizontally and vertically in order to show every pair of connections between the nodes. In this case, since our grid has $n \\times n = n^2$ lattices, the matrix will be much larger. Essentially, what we are doing is making a long vector out of the lattice and then making that long vector 2D by taking the outer product of two long vectors.\n\n$$\n\\begin{gather*}\n  \\begin{bmatrix}\n  \\textcolor{red}{1} & \\textcolor{red}{2} & \\textcolor{red}{3} \\\\\n  \\textcolor{blue}{4} & \\textcolor{blue}{5} & \\textcolor{blue}{6} \\\\\n  \\textcolor{green}{7} & \\textcolor{green}{8} & \\textcolor{green}{9} \\\\\n  \\end{bmatrix}\n  \\longrightarrow \n  \\begin{bmatrix}\n  \\textcolor{red}{1} \\\\ \\textcolor{red}{2} \\\\ \\textcolor{red}{3} \\\\ \\textcolor{blue}{4} \\\\ \\textcolor{blue}{5} \\\\ \\textcolor{blue}{6} \\\\ \\textcolor{green}{7} \\\\ \\textcolor{green}{8} \\\\ \\textcolor{green}{9} \\\\ \\end{bmatrix} \n  \\longrightarrow\n\\begin{bmatrix}  1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ 6 \\\\ 7 \\\\ 8 \\\\ 9 \\\\ \\end{bmatrix} \n\\begin{bmatrix} 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\end{bmatrix}\n  \\longrightarrow\n  \\begin{bmatrix}\n  &1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\\\\n  1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ 6 \\\\ 7 \\\\ 8 \\\\ 9 \\\\\n  \\end{bmatrix} \\\\\n  \\space\\space\\text{Lattice}\\space\\space\\space\\space\\space\\space\\space\\text{Long Vector}\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\text{Outer Product}\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\text{2D Long Vector}\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\n\\end{gather*}\n$$\n\n### Making the Lattice Adjacency Matrix\n\nNow that the matrix is made, we can use the 2D to 1D conversion formula: $(\\text{row} -1) \\times \\text{row length} + \\text{column}$. This helps streamline the process of actually assigning what squares are adjacent to one another when a knight jumps. For every single cell, we can just calculate the knight moves with a helper function and then assign them a 1 or 0 if they are adjacent.\n\nThe end result looks like this:\n\n```{r, \"Image\", echo=FALSE}\nimage(makeLatticeAdjMatrix())\n```\n\nNow, the reason why we wanted to go through all this trouble was because adjacency matrices are very useful for showing future movement from any starting point. This is done as easily as just exponentiating the adjacency matrix $A$ to some degree $n$. In doing so, from the basic properties of matrix multiplication, we can determine all of the possible paths of length $n$ that start and end anywhere. For example, by taking the matrix $A$ from before (representative of [Graph -@suppfig-custom].), computing $A^2$, and zooming in on the results for the paths that end at node 2 after 2 walks, we can see this clearly:\n\n$$\n\\begin{equation*}\n\\begin{gathered}\n  A =\n  \\begin{bmatrix}\n  0 & 1 & 0 & 1 \\\\\n  1 & 0 & 0 & 1 \\\\\n  0 & 0 & 0 & 1 \\\\\n  1 & 1 & 1 & 0 \\\\\n  \\end{bmatrix}\n  \\\\[1em]\n  A \\times A =\n  \\begin{bmatrix}\n  \\cdot & \\color{red}{(0 \\cdot 1) + (1 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(1 \\cdot 1) + (0 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(0 \\cdot 1) + (0 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(1 \\cdot 1) + (1 \\cdot 0) + (1 \\cdot 0) + (0 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\end{bmatrix}\n  =\n  \\begin{bmatrix}\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{2} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\end{bmatrix}\n  \\\\[1em]\n  \\begin{array}{c c l}\n    \\textbf{Start} & \\textbf{Count} & \\textbf{Explanation} \\\\\n    1 & 1 & \\text{1 path from node 1 of } \\textcolor{red}{\\text{length }\\textbf{2}} \\text{ to node 2} \\\\\n    2 & 2 & \\text{2 paths from node 2 of } \\textcolor{blue}{\\text{length }\\textbf{2}} \\text{ to node 2}\\\\\n    3 & 1 & \\text{1 path from node 3 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2}\\\\\n    4 & 1 & \\text{1 path from node 4 of } \\textcolor{purple}{\\text{length }\\textbf{2}} \\text{ to node 2}\\\\\n    \\end{array}\n\\end{gathered}\n\\end{equation*}\n$$\n\n![Fig. 3: All of the paths extending to node 2 with 2 edges, as representative of col. 2 of $A^2$](images/graphExample3.png){.lightbox fig-align=\"center\" width=\"300\"}\n\nHere it can clearly be seen that, just as before, when we look at the column 2, we find all of the nodes that have a connection with node 2, but this time it is if they have a path of 2 walks (from raising $A$ to $n = 2$). This allows for there to be more numbers than just 0 and 1 as it's possible that nodes have 2 ways to get to node 2 in 2 moves, just like in the case of node 2.\n\nAnd there is no limit on how high the exponent can go-- meaning that if it weren't for computation time or the bigger inhibitor of digit space, the shiny app can display thousands of moves into the future.\n\n### What It All Means\n\nWhile this project may not be the most practical application, the patterns that emerge in the app highlight broadly useful concepts from linear algebra. If you interact with the app long enough, you will notice that certain squares — particularly the central squares — consistently have the highest count or probability of the knight landing on them. This behavior mirrors the idea of eigenvalues in a matrix, which predict long-term behavior: in this case, how the tiles' 'popularity' evolves after multiple moves. Eigenvalues essentially tell us the dominant patterns of movement that emerge after many iterations, with higher eigenvalues corresponding to squares that are more likely to be landed on.\n\nIn some setups, there is a switch between light squares dominating or dark squares dominating depending on whether the exponent is odd or even. This is a result of the bipartite nature of the board: the board can be divided into two distinct sets of squares (light and dark), and squares within each set are not connected to others of the same set. This property is crucial because it suggests that the eigenvalues of the matrix governing the knight’s movement are symmetric around zero. Specifically, for matrices with this symmetry, we have $\\lambda \\times m = -\\lambda \\times m$, which explains why odd and even powers of the matrix lead to such different behaviors. The switch between the odd and even powers of the matrix helps to explain the shifting dominance of the squares. When we raise the matrix to odd powers, the behavior tends to favor one set (either light or dark squares), while raising it to even powers leads to a more balanced or alternating pattern, as the symmetry of the eigenvalues becomes more apparent.\n\nAdjacency matrices can be very powerful tools, helping with topics such as the [spread of infectious disease](https://arxiv.org/abs/2207.02737), [Google's PageRank](https://math.libretexts.org/Bookshelves/Linear_Algebra/Understanding_Linear_Algebra_(Austin)/04%3A_Eigenvalues_and_eigenvectors/4.05%3A_Markov_chains_and_Google's_PageRank_algorithm), and [weather forecast](https://www.researchgate.net/publication/350840280_Applications_of_Markov_Chain_in_Forecast).\n\n# References\n\nBrualdi, Richard. “The Mutually Beneficial Relationship of Graphs and Matrices.” CBMS Regional Conference Series in Mathematics, vol. 115, no. 1, 6 July 2011, pp. 14–23, [www.ams.org/bookstore/pspdf/cbms-115-prev.pdf](www.ams.org/bookstore/pspdf/cbms-115-prev.pdf), <https://doi.org/10.1090/cbms/115>. Accessed 9 Sept. 2025.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","resources":["../../Miles_LibbeyV_Resume_2025.pdf"],"editor":"source","theme":"lumen","page-layout":"article","grid":{"body-width":"1000px","margin-width":"300px","sidebar-width":"550px","gutter-width":"1.5em"},"page-footer":{"left":"&copy; Miles Libbey V, 2025<br>\nAll content licensed under <i class='bi-badge-cc'></i>\n[(CC BY-NC-SA 4.0)](http://creativecommons.org/licenses/by-nc-sa/4.0/)\n","right":"Site built with <a href='https://quarto.org/'>Quarto</a>\n"},"title":"Knight's Tour Adjacency Matrix Visual","author":"Miles Libbey V","image":"icon.png","categories":["Self-Directed","R"],"crossref":{"custom":[{"kind":"float","key":"suppfig","latex-env":"suppfig","reference-prefix":"Fig.","space-before-numbering":true,"latex-list-of-description":"Supplementary Figure"}]}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}