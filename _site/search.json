[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Miles Libbey V",
    "section": "",
    "text": "Hello! I am Miles Libbey V, I graduated Cum Laude from Macalester College studying Data Science with pursuits in Psychology, Spanish, Linguistics, and Political Science. Not too long ago, I conducted research in Linguistics under the department chair and a team of many students all from varying disciplines in order to produce a pending article about the dissimilarity of vocalic phonation distinctions across sex and gender. I am also involved with many non-profits in the Bay Area (where I am from) and the Twin Cities, the latest being The ARC Minnesota, a nonprofit dedicated to providing support to people wit intellectual development disabilities (IDD) in an array of ways, where I acted as a Development Intern. Outside of work, I really enjoy dancing– at one point I was involved with 3 individual dance groups both in school and outside (though, I am definitely still a learner in this field).\n\n\n\n\nMacalester College 2021 - 2025 | St. Paul MN\nB.A. in Data Science | Sept 2021 - May 2025"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\nNonprofit Leaflet\n\n\n\nSelf-Directed\n\n\nR\n\n\nGraphQL\n\n\n\n\n\n\n\nMiles Libbey V\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMadrid Metro MySQL Database\n\n\n\nUniversity\n\n\nMySQL\n\n\n\n\n\n\n\nMiles Libbey V\n\n\n\n\n\n\n\n\n\n\n\n\nLoneliness Project\n\n\n\nUniversity\n\n\nSelf-Directed\n\n\nPython\n\n\n\n\n\n\n\nMiles Libbey V\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKnight’s Tour Adjacency Matrix Visual\n\n\n\nSelf-Directed\n\n\nR\n\n\n\n\n\n\n\nMiles Libbey V\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHousing Status Changes in Substance Abuse Treatment\n\n\n\nUniversity\n\n\nR\n\n\nPython\n\n\n\n\n\n\n\nMiles Libbey V\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html#about-me",
    "href": "index.html#about-me",
    "title": "Miles Libbey V",
    "section": "",
    "text": "Hello! I am Miles Libbey V, I graduated Cum Laude from Macalester College studying Data Science with pursuits in Psychology, Spanish, Linguistics, and Political Science. Not too long ago, I conducted research in Linguistics under the department chair and a team of many students all from varying disciplines. I am also involved with many non-profits in the Bay Area (where I am from) and the Twin Cities, the latest being The Arc Minnesota, where I am acting as a Development Intern. Outside of work, I really enjoy dancing– at one point I was involved with 3 individual dance groups both in school and outside (though, I am definitely still a learner in this field).\n\n\n\n\nMacalester College | St. Paul MN\nB.A. in Data Science | Sept 2021 - May 2025"
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "Miles Libbey V",
    "section": "",
    "text": "Macalester College 2021 - 2025 | St. Paul MN\nB.A. in Data Science | Sept 2021 - May 2025"
  },
  {
    "objectID": "projects/capstonePortfolio/index.html",
    "href": "projects/capstonePortfolio/index.html",
    "title": "Housing Status Changes in Substance Abuse Treatment",
    "section": "",
    "text": "This project was a one of 3 subsets of a larger project done for the Senior Capstone class Projects In Data Science aimed at analyzing SAMHSA’s TEDS-D (Treatment Episodic Data Set-Discharges) 2021 file in seeing how vital quality of life influences– employment status, housing status, and frequency of substance use– changed throughout the time substance abuse facility clients’ stay. This was accomplished from use of 2 time interval variables measuring the same aspect. For example, EMPLOY and EMPLOY_D measured employment at admission and employment at departure respectively.\nSpecifically, this project set out to answer the question, What are the key differences in the characteristics of people whose living arrangements do or do Not change after treatment? In order to provide evidence, it dove into what the composite differences were between those who remained unhoused and those who went from being unhoused to living independently (with a slight interest in looking at those who came in living independently and became unhoused, only 0.6% of clients). This was all done in R, with some use of Python for running models unavailable in R (CatBoost and retreiving the SHAP values of those)."
  },
  {
    "objectID": "projects/madridMetro/index.html",
    "href": "projects/madridMetro/index.html",
    "title": "Madrid Metro MySQL Database",
    "section": "",
    "text": "Designed and implemented a MySQL database for Madrid’s metro system with detailed schema and features based on a list of assumptions, including reactive triggers and events for calculating pricing, managing metro card validity, and handling client transactions dynamically based on age, city zone, and discount eligibility."
  },
  {
    "objectID": "projects/madridMetro/index.html#eer-diagram",
    "href": "projects/madridMetro/index.html#eer-diagram",
    "title": "Madrid Metro MySQL Database",
    "section": "EER Diagram:",
    "text": "EER Diagram:"
  },
  {
    "objectID": "projects/madridMetro/index.html#schema-diagram",
    "href": "projects/madridMetro/index.html#schema-diagram",
    "title": "Madrid Metro MySQL Database",
    "section": "Schema Diagram:",
    "text": "Schema Diagram:"
  },
  {
    "objectID": "projects/capstonePortfolio/index.html#catboostclassifier",
    "href": "projects/capstonePortfolio/index.html#catboostclassifier",
    "title": "Housing Status Changes in Substance Abuse Treatment",
    "section": "CatboostClassifier",
    "text": "CatboostClassifier\nCatBoost is a gradient boosting model (like LightGM and XGBoost) that has a special CatBoost target encoding that makes it shine above the others for this project. Its unique target encoding allows for more effective and efficient predictions with categorical data, which is the datatype of 97% of the columns.\nX = teds_Unhoused.drop(columns=[\"LIVARAG_delta\"]) \nX = X.astype(str)\ny = teds_Unhoused[\"LIVARAG_delta\"] \n\ntrain_pool = Pool(X, label=y, cat_features=X.columns.tolist())\n\nmodelUnhoused = CatBoostClassifier(iterations=700, \n                           depth=8, \n                           learning_rate=0.2, \n                           loss_function='Logloss', \n                           eval_metric='AUC', \n                           verbose=70)\n\nmodelUnhoused.fit(train_pool)\n\n\n\n\n\n\n\n\n\n\n\nShap Values\n\n\n\n\n\n\n\nSHAP values give a little insight into how variables actually sway the classifier’s decision. In this plot, every dot is representative of one case, or one client. The further right a dot is, the higher probability of the client changing from unhoused to house is and vice versa. Since every dot is a single person, those humps are all people, so it is easy to spot that there are many groups in the variables. What is important to see is that there is a trend for these variables to leaning towards the right, with many large humps and tails being there. However, these variables aren’t just univariate and some have good sized humps on the left like in the case of State and Length of Stay. The next model gives insight into which models are more likely to be doing this.\n\n\n\n\n\n\n\n- Include thank you’s to experts\n\n\nWorks Cited\nBrubaker, Michael D., et al. “Barriers and Supports to Substance Abuse Service Use among Homeless Adults.” Journal of Addictions & Offender Counseling, vol. 34, no. 2, Oct. 2013, pp. 81–98, https://doi.org/10.1002/j.2161-1874.2013.00017.x. Accessed 24 October. 2024.\nNicholls, Melanie J., and Lianne A. Urada. “Homelessness and Polysubstance Use: A Qualitative Study on Recovery and Treatment Access Solutions around an Urban Library in Southern California, USA.” Health & Social Care in the Community, vol. 30, no. 1, 14 May 2021, https://doi.org/10.1111/hsc.13424.\nSubstance Abuse and Mental Health Services Administration. (2023). Treatment Episode Data\nSet Discharges (TEDS-D) 2021: Public Use File (PUF) Codebook. Rockville, MD: Center for Behavioral Health Statistics and Quality, Substance Abuse and Mental Health Services Administration. Retrieved from https://www.samhsa.gov/data/."
  },
  {
    "objectID": "projects/KnightTourVisual/index.html",
    "href": "projects/KnightTourVisual/index.html",
    "title": "KnightTourMatrixVisual",
    "section": "",
    "text": "An adjacency matrix is a type of matrix used to represent a mathmatical graph, as pictured below:\n\n\n\n\n\nThe matrix shows which vertices are adjacent to one another and which are not. It can be thought of as this: rows are the starting points and the columns are the ending points. If you can get from a starting point to an ending point, then a 1 is placed, and a 0 is placed if not.\n\\[\nA =\n\\begin{bmatrix}\n0 & 1 & 0 & 1 \\\\\n1 & 0 & 0 & 1 \\\\\n0 & 0 & 0 & 1 \\\\\n1 & 1 & 1 & 0 \\\\\n\\end{bmatrix}\n\\]\nFor example, in our graph, 2 and 4 are connected, so if you look in the 2nd row (the starting place) and then look at the 4th row (the ending place), you will see that there is a 1. Vice versa, if you look at \\(A_{2,3}\\) you will see that it is a 0, meaning 2 and 3 are unconnected, which can be confirmed from looking at the graph. These are always square \\(n \\times n\\) matrices because it just the same vertices being shown in the both and rows and columns. How this relates to a knight is if you imagine the vertices as chess squares, we can graph what the knight can make in one move (we will be able to show multiple moves but we are not there yet).\nHowever, chess squares have defined places where they are. In this graph, 1 can be put to the right of 4 and it wouldn’t matter.\n\n\n\n\n\n\n\nThere is not different between this graph and the one before\n\n\nWe need to introduce a system of order to the graph to make it more of a rigid grid. This is precisely why using a Lattice graph is so helpful in this case. Lattice graphs offer distinct coordinates, or latices, which line up exactly with what we want to do with the chess squares because each squares is distinct and has 2-dimensional coordinates (i.e. the point (1,2) has an x dimension and a y dimension).\n\\[\n\\begin{bmatrix}\n(1,1) & (1,2) & (1,3) \\\\\n(2,1) & (2,2) & (2,3) \\\\\n(3,1) & (3,2) & (3,3) \\\\\n\\end{bmatrix}\n\\\\\n\\text{Latice Matrix}\n\\]\nJust as we made a adjacency matrix out of a normal, we can make a lattice adjacency matrix out of a lattice graph. For our purposes, lattice matrices are just regular matrices but each entry in the matrix is representative of a lattice point.\nIn order to make a lattice adjacency matrix given an \\(n \\times n\\) lattice, we will essentially construct a \\(n^2 \\times n^2\\) matrix. This comes from exactly what we did with the adjacency matrices; every single node was put across horizontally and vertically in order to have every pairs of connections between the nodes. Just in this case, since our grid has \\(n \\times n = n^2\\) lattices, it will be much larger. Essentially what we’re doing is making a long vector out of the lattice and then making that long vector 2D by taking the outerproduct of 2 of long vectors.\n\\[\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9 \\\\\n\\end{bmatrix}\n\\longrightarrow\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ 6 \\\\ 7 \\\\ 8 \\\\ 9 \\\\ \\end{bmatrix}\n\\longrightarrow\n\\begin{bmatrix}\n&1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\\\\n1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ 6 \\\\ 7 \\\\ 8 \\\\ 9 \\\\\n\\end{bmatrix} \\\\\n\\space\\space\\text{Lattice}\\space\\space\\space\\space\\space\\space\\space\\text{Long Vector}\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\text{2D Long Vector}\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\n\\]\nNow that the matrix is made, we can use the 2D to 1D conversion formula: \\((\\text{row} -1) \\times \\text{row length} + \\text{column}\\). This helps streamline the process of actually assigning what squares are adjacent to one another when a knight jumps. For every single cell, we can just calculate the knight moves with a helper function and then assign them a 1 or 0 if they are adjacent.\nThe end result looks like this:\n\n\n\n\n\n\n\n\n\nNow, the reason why we wanted to go through all this trouble was because adjacency matrices are very useful for showing continued movement. This is done as easily as just exponentiating the adjacency matrix \\(A\\) to some degree \\(n\\). In doing so, from the basic properties of matrix multiplication,"
  },
  {
    "objectID": "projects/KnightTourVisual/index.html#imports",
    "href": "projects/KnightTourVisual/index.html#imports",
    "title": "KnightTourMatrixVisual",
    "section": "",
    "text": "library(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(Matrix)\n\n\nAttaching package: 'Matrix'\n\nThe following objects are masked from 'package:tidyr':\n\n    expand, pack, unpack\n\nlibrary(purrr)\nlibrary(expm)\n\n\nAttaching package: 'expm'\n\nThe following object is masked from 'package:Matrix':\n\n    expm\n\nlibrary(plotly)\n\n\nAttaching package: 'plotly'\n\nThe following object is masked from 'package:ggplot2':\n\n    last_plot\n\nThe following object is masked from 'package:stats':\n\n    filter\n\nThe following object is masked from 'package:graphics':\n\n    layout\n\nlibrary(stringr)\nlibrary(shiny)\nlibrary(grid)\n\n'%notin%' &lt;- Negate('%in%')"
  },
  {
    "objectID": "projects/KnightTourVisual/index.html#custom-helper-functions",
    "href": "projects/KnightTourVisual/index.html#custom-helper-functions",
    "title": "KnightTourMatrixVisual",
    "section": "Custom Helper Functions",
    "text": "Custom Helper Functions\n\ngenerate_combinations &lt;- function(ops, nums) {\n  # Convert to numeric if character\n  nums &lt;- as.numeric(nums)\n\n  # Generate all permutations of numbers\n  permute &lt;- function(v) {\n    if (length(v) == 1) return(list(v))\n    out &lt;- list()\n    for (i in seq_along(v)) {\n      rest &lt;- v[-i]\n      for (p in permute(rest)) {\n        out &lt;- append(out, list(c(v[i], p)))\n      }\n    }\n    return(out)\n  }\n\n  # Parse operations into functions\n  parse_op &lt;- function(op_string) {\n    if (op_string == \"+\") {\n      return(function(x) x)\n    } else if (op_string == \"-\") {\n      return(function(x) -x)\n    } else if (grepl(\"^\\\\^\", op_string)) {\n      n &lt;- as.numeric(sub(\"^\\\\^\", \"\", op_string))\n      return(function(x) x^n)\n    } else if (grepl(\"^/\", op_string)) {\n      n &lt;- as.numeric(sub(\"^/\", \"\", op_string))\n      return(function(x) x / n)\n    } else {\n      stop(paste(\"Unknown operation:\", op_string))\n    }\n  }\n\n  # Convert all ops to functions\n  op_funcs &lt;- lapply(ops, parse_op)\n\n  # Get all combinations of operations (each element gets an op)\n  op_combos &lt;- expand.grid(rep(list(seq_along(op_funcs)), length(nums)))\n  \n  # Generate number permutations\n  num_perms &lt;- permute(nums)\n\n  result &lt;- list()\n\n  for (perm in num_perms) {\n    for (i in 1:nrow(op_combos)) {\n      indices &lt;- as.integer(op_combos[i, ])\n      funcs &lt;- op_funcs[indices]\n      transformed &lt;- mapply(function(f, x) f(x), funcs, perm)\n      result &lt;- append(result, list(transformed))\n    }\n  }\n\n  return(result)\n}\n\n# generate_combinations(c(\"+\", \"-\"), c(1, 2))\nmakeKnightMoves &lt;- function(position, board_dims = c(8,8)) {\n  position &lt;- as.numeric(position)\n  numRows &lt;- board_dims[1]\n  numCols &lt;- board_dims[2]\n  \n  ifValid &lt;- function(placement) {\n    rowInBounds &lt;- placement[1] &gt;= 1 && placement[1] &lt;= numRows\n    colInBounds &lt;- placement[2] &gt;= 1 && placement[2] &lt;= numCols\n    return(rowInBounds && colInBounds)\n  }\n  \n  # Validate input\n  if (!ifValid(position)) {\n    stop(\"Please enter values within board dimensions\")\n  }\n\n  movesList &lt;- lapply(generate_combinations(c(\"+\", \"-\"), c(1, 2)), function(a){\n    newPosition &lt;- c(position[1] + a[1], position[2] + a[2])\n    if (ifValid(newPosition)) {\n      return(newPosition)\n    } else {\n      return(NULL)\n    }\n  })\n  \n  return(compact(movesList))\n}\n\nmakeKnightMoves(c(8,7), c(8,7))\n\n[[1]]\n[1] 7 5\n\n[[2]]\n[1] 6 6"
  },
  {
    "objectID": "projects/KnightTourVisual/index.html#lattice-adjacency-matrix",
    "href": "projects/KnightTourVisual/index.html#lattice-adjacency-matrix",
    "title": "KnightTourMatrixVisual",
    "section": "",
    "text": "An adjacency matrix is a type of matrix used to represent a mathmatical graph, as pictured below:\n\n\n\n\n\nThe matrix shows which vertices are adjacent to one another and which are not. It can be thought of as this: rows are the starting points and the columns are the ending points. If you can get from a starting point to an ending point, then a 1 is placed, and a 0 is placed if not.\n\\[\nA =\n\\begin{bmatrix}\n0 & 1 & 0 & 1 \\\\\n1 & 0 & 0 & 1 \\\\\n0 & 0 & 0 & 1 \\\\\n1 & 1 & 1 & 0 \\\\\n\\end{bmatrix}\n\\]\nFor example, in our graph, 2 and 4 are connected, so if you look in the 2nd row (the starting place) and then look at the 4th row (the ending place), you will see that there is a 1. Vice versa, if you look at \\(A_{2,3}\\) you will see that it is a 0, meaning 2 and 3 are unconnected, which can be confirmed from looking at the graph. These are always square \\(n \\times n\\) matrices because it just the same vertices being shown in the both and rows and columns. How this relates to a knight is if you imagine the vertices as chess squares, we can graph what the knight can make in one move (we will be able to show multiple moves but we are not there yet).\nHowever, chess squares have defined places where they are. In this graph, 1 can be put to the right of 4 and it wouldn’t matter.\n\n\n\n\n\n\n\nThere is not different between this graph and the one before\n\n\nWe need to introduce a system of order to the graph to make it more of a rigid grid. This is precisely why using a Lattice graph is so helpful in this case. Lattice graphs offer distinct coordinates, or latices, which line up exactly with what we want to do with the chess squares because each squares is distinct and has 2-dimensional coordinates (i.e. the point (1,2) has an x dimension and a y dimension).\n\\[\n\\begin{bmatrix}\n(1,1) & (1,2) & (1,3) \\\\\n(2,1) & (2,2) & (2,3) \\\\\n(3,1) & (3,2) & (3,3) \\\\\n\\end{bmatrix}\n\\\\\n\\text{Latice Matrix}\n\\]\nJust as we made a adjacency matrix out of a normal, we can make a lattice adjacency matrix out of a lattice graph. For our purposes, lattice matrices are just regular matrices but each entry in the matrix is representative of a lattice point.\nIn order to make a lattice adjacency matrix given an \\(n \\times n\\) lattice, we will essentially construct a \\(n^2 \\times n^2\\) matrix. This comes from exactly what we did with the adjacency matrices; every single node was put across horizontally and vertically in order to have every pairs of connections between the nodes. Just in this case, since our grid has \\(n \\times n = n^2\\) lattices, it will be much larger. Essentially what we’re doing is making a long vector out of the lattice and then making that long vector 2D by taking the outerproduct of 2 of long vectors.\n\\[\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9 \\\\\n\\end{bmatrix}\n\\longrightarrow\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ 6 \\\\ 7 \\\\ 8 \\\\ 9 \\\\ \\end{bmatrix}\n\\longrightarrow\n\\begin{bmatrix}\n&1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\\\\n1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ 6 \\\\ 7 \\\\ 8 \\\\ 9 \\\\\n\\end{bmatrix} \\\\\n\\space\\space\\text{Lattice}\\space\\space\\space\\space\\space\\space\\space\\text{Long Vector}\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\text{2D Long Vector}\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\n\\]\nNow that the matrix is made, we can use the 2D to 1D conversion formula: \\((\\text{row} -1) \\times \\text{row length} + \\text{column}\\). This helps streamline the process of actually assigning what squares are adjacent to one another when a knight jumps. For every single cell, we can just calculate the knight moves with a helper function and then assign them a 1 or 0 if they are adjacent.\nThe end result looks like this:\n\n\n\n\n\n\n\n\n\nNow, the reason why we wanted to go through all this trouble was because adjacency matrices are very useful for showing continued movement. This is done as easily as just exponentiating the adjacency matrix \\(A\\) to some degree \\(n\\). In doing so, from the basic properties of matrix multiplication,"
  },
  {
    "objectID": "projects/KnightTourVisual/index.html#actual-plot",
    "href": "projects/KnightTourVisual/index.html#actual-plot",
    "title": "KnightTourMatrixVisual",
    "section": "Actual Plot",
    "text": "Actual Plot\nNow, the reason why we wanted to go through all this trouble was because adjacency matrices are very useful for showing continued movement. This is done as easily as just exponentiating the adjacency matrix \\(A\\) to some degree \\(n\\). In doing so, from the basic properties of matrix multiplication,"
  },
  {
    "objectID": "projects/KnightTourVisual/index.html#shiny-app",
    "href": "projects/KnightTourVisual/index.html#shiny-app",
    "title": "KnightTourMatrixVisual",
    "section": "Shiny App",
    "text": "Shiny App"
  },
  {
    "objectID": "projects/KnightTourVisual/app.html",
    "href": "projects/KnightTourVisual/app.html",
    "title": "Knight’s Tour Adjacency Matrix Visual",
    "section": "",
    "text": "Below you will find a Shiny App made for fun using concepts learned in Linear Algebra and Computational Linear Algebra, most notably graphs, adjacency matrices, matrix exponentiation. All of the concepts used to build the app are explained from an introductory level if you are interested in learning what is going on behind the scenes."
  },
  {
    "objectID": "projects/KnightTourVisual/app.html#lattice-adjacency-matrix",
    "href": "projects/KnightTourVisual/app.html#lattice-adjacency-matrix",
    "title": "Knight’s Tour Adjacency Matrix Visual",
    "section": "",
    "text": "An adjacency matrix is a type of matrix used to represent a mathmatical graph, as pictured below:\n\n\n\n\n\nThe matrix shows which vertices are adjacent to one another and which are not. It can be thought of as this: rows are the starting points and the columns are the ending points. If you can get from a starting point to an ending point, then a 1 is placed, and a 0 is placed if not.\n\\[\nA =\n\\begin{bmatrix}\n0 & 1 & 0 & 1 \\\\\n1 & 0 & 0 & 1 \\\\\n0 & 0 & 0 & 1 \\\\\n1 & 1 & 1 & 0 \\\\\n\\end{bmatrix}\n\\]\nFor example, in our graph, 2 and 4 are connected, so if you look in the 2nd row (the starting place) and then look at the 4th row (the ending place), you will see that there is a 1. Vice versa, if you look at \\(A_{2,3}\\) you will see that it is a 0, meaning 2 and 3 are unconnected, which can be confirmed from looking at the graph. These are always square \\(n \\times n\\) matrices because it just the same vertices being shown in the both and rows and columns. How this relates to a knight is if you imagine the vertices as chess squares, we can graph what the knight can make in one move (we will be able to show multiple moves but we are not there yet).\nHowever, chess squares have defined places where they are. In this graph, 1 can be put to the right of 4 and it wouldn’t matter.\n\n\n\n\n\n\n\nThere is not different between this graph and the one before\n\n\nWe need to introduce a system of order to the graph to make it more of a rigid grid. This is precisely why using a Lattice graph is so helpful in this case. Lattice graphs offer distinct coordinates, or latices, which line up exactly with what we want to do with the chess squares because each squares is distinct and has 2-dimensional coordinates (i.e. the point (1,2) has an x dimension and a y dimension).\n\\[\n\\begin{gather*}\n\\begin{bmatrix}\n(1,1) & (1,2) & (1,3) \\\\\n(2,1) & (2,2) & (2,3) \\\\\n(3,1) & (3,2) & (3,3) \\\\\n\\end{bmatrix} \\\\\n\\text{Lattice Matrix}\n\\end{gather*}\n\\]\nJust as we made a adjacency matrix out of a normal, we can make a lattice adjacency matrix out of a lattice graph. For our purposes, lattice matrices are just regular matrices but each entry in the matrix is representative of a lattice point.\nIn order to make a lattice adjacency matrix given an \\(n \\times n\\) lattice, we will essentially construct a \\(n^2 \\times n^2\\) matrix. This comes from exactly what we did with the adjacency matrices; every single node was put across horizontally and vertically in order to have every pairs of connections between the nodes. Just in this case, since our grid has \\(n \\times n = n^2\\) lattices, it will be much larger. Essentially what we’re doing is making a long vector out of the lattice and then making that long vector 2D by taking the outerproduct of 2 of long vectors.\n\\[\n\\begin{gather*}\n  \\begin{bmatrix}\n  1 & 2 & 3 \\\\\n  4 & 5 & 6 \\\\\n  7 & 8 & 9 \\\\\n  \\end{bmatrix}\n  \\longrightarrow\n  \\begin{bmatrix}\n  1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ 6 \\\\ 7 \\\\ 8 \\\\ 9 \\\\ \\end{bmatrix}\n  \\longrightarrow\n  \\begin{bmatrix}\n  &1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\\\\n  1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ 6 \\\\ 7 \\\\ 8 \\\\ 9 \\\\\n  \\end{bmatrix} \\\\\n  \\space\\space\\text{Lattice}\\space\\space\\space\\space\\space\\space\\space\\text{Long Vector}\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\text{2D Long Vector}\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\n\\end{gather*}\n\\]\nNow that the matrix is made, we can use the 2D to 1D conversion formula: \\((\\text{row} -1) \\times \\text{row length} + \\text{column}\\). This helps streamline the process of actually assigning what squares are adjacent to one another when a knight jumps. For every single cell, we can just calculate the knight moves with a helper function and then assign them a 1 or 0 if they are adjacent.\nThe end result looks like this:\n\n\n\n\n\n\n\n\n\nNow, the reason why we wanted to go through all this trouble was because adjacency matrices are very useful for showing future movement from any starting point. This is done as easily as just exponentiating the adjacency matrix \\(A\\) to some degree \\(n\\). In doing so, from the basic properties of matrix multiplication, which we can see clearly using the matrix \\(A\\) from before and making \\(A^2\\) and zooming in on the results of node 2:\n\\[\n\\begin{equation*}\n\\begin{gathered}\n  A =\n  \\begin{bmatrix}\n  0 & 1 & 0 & 1 \\\\\n  1 & 0 & 0 & 1 \\\\\n  0 & 0 & 0 & 1 \\\\\n  1 & 1 & 1 & 0 \\\\\n  \\end{bmatrix}\n  \\\\\n  A \\times A =\n  \\begin{bmatrix}\n  \\cdot & \\color{red}{(0 \\cdot 1) + (1 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(1 \\cdot 1) + (0 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(0 \\cdot 1) + (0 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(1 \\cdot 1) + (1 \\cdot 0) + (1 \\cdot 0) + (0 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\end{bmatrix}\n  =\n  \\begin{bmatrix}\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{2} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\end{bmatrix}\n  \\\\[2em]\n  \\begin{array}{c c l}\n    \\textbf{Start} & \\textbf{Count} & \\textbf{Explanation} \\\\\n    1 & 1 & \\text{1 path from node 1 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2: } (1 → 4 → 2) \\\\\n    2 & 2 & \\text{2 paths from node 2 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2: } (2 → 1 → 2), (2 → 4 → 2) \\\\\n    3 & 1 & \\text{1 path from node 3 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2: } (3 → 4 → 2) \\\\\n    4 & 1 & \\text{1 path from node 4 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2: } (4 → 1 → 2) \\\\\n    \\end{array}\n\\end{gathered}\n\\end{equation*}\n\\]"
  },
  {
    "objectID": "projects/KnightTourVisual/app.html#shiny-app",
    "href": "projects/KnightTourVisual/app.html#shiny-app",
    "title": "Knight’s Tour Adjacency Matrix Visual",
    "section": "Shiny App",
    "text": "Shiny App"
  },
  {
    "objectID": "projects/KnightTourVisual/app.html#introduction-to-the-math-behind-the-app",
    "href": "projects/KnightTourVisual/app.html#introduction-to-the-math-behind-the-app",
    "title": "Knight’s Tour Adjacency Matrix Visual",
    "section": "",
    "text": "An adjacency matrix is a type of matrix used to represent a mathmatical graph, as pictured below:\n\n\n\n\n\nThe matrix shows which vertices are adjacent to one another and which are not. It can be thought of as this: rows are the starting points and the columns are the ending points. If you can get from a starting point to an ending point, then a 1 is placed, and a 0 is placed if not.\n\\[\nA =\n\\begin{bmatrix}\n0 & 1 & 0 & 1 \\\\\n1 & 0 & 0 & 1 \\\\\n0 & 0 & 0 & 1 \\\\\n1 & 1 & 1 & 0 \\\\\n\\end{bmatrix}\n\\]\nFor example, in our graph, 2 and 4 are connected, so if you look in the 2nd row (the starting place) and then look at the 4th row (the ending place), you will see that there is a 1. Vice versa, if you look at \\(A_{2,3}\\) you will see that it is a 0, meaning 2 and 3 are unconnected, which can be confirmed from looking at the graph. These are always square \\(n \\times n\\) matrices because it just the same vertices being shown in the both and rows and columns. How this relates to a knight is if you imagine the vertices as chess squares, we can graph what the knight can make in one move (we will be able to show multiple moves but we are not there yet).\nHowever, chess squares have defined places where they are. In this graph, 1 can be put to the right of 4 and it wouldn’t matter.\n\n\n\n\n\n\n\nThere is not different between this graph and the one before\n\n\n\n\n\nWe need to introduce a system of order to the graph to make it more of a rigid grid. This is precisely why using a Lattice graph is so helpful in this case. Lattice graphs offer distinct coordinates, or latices, which line up exactly with what we want to do with the chess squares because each squares is distinct and has 2-dimensional coordinates (i.e. the point (1,2) has an x dimension and a y dimension).\n\\[\n\\begin{gather*}\n\\begin{bmatrix}\n(1,1) & (1,2) & (1,3) \\\\\n(2,1) & (2,2) & (2,3) \\\\\n(3,1) & (3,2) & (3,3) \\\\\n\\end{bmatrix} \\\\\n\\text{Lattice Matrix}\n\\end{gather*}\n\\]\nJust as we made a adjacency matrix out of a normal, we can make a lattice adjacency matrix out of a lattice graph. For our purposes, lattice matrices are just regular matrices but each entry in the matrix is representative of a lattice point.\nIn order to make a lattice adjacency matrix given an \\(n \\times n\\) lattice, we will essentially construct a \\(n^2 \\times n^2\\) matrix. This comes from exactly what we did with the adjacency matrices; every single node was put across horizontally and vertically in order to have every pairs of connections between the nodes. Just in this case, since our grid has \\(n \\times n = n^2\\) lattices, it will be much larger. Essentially what we’re doing is making a long vector out of the lattice and then making that long vector 2D by taking the outerproduct of 2 of long vectors.\n\\[\n\\begin{gather*}\n  \\begin{bmatrix}\n  1 & 2 & 3 \\\\\n  4 & 5 & 6 \\\\\n  7 & 8 & 9 \\\\\n  \\end{bmatrix}\n  \\longrightarrow\n  \\begin{bmatrix}\n  1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ 6 \\\\ 7 \\\\ 8 \\\\ 9 \\\\ \\end{bmatrix}\n  \\longrightarrow\n  \\begin{bmatrix}\n  &1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\\\\n  1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ 6 \\\\ 7 \\\\ 8 \\\\ 9 \\\\\n  \\end{bmatrix} \\\\\n  \\space\\space\\text{Lattice}\\space\\space\\space\\space\\space\\space\\space\\text{Long Vector}\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\text{2D Long Vector}\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\n\\end{gather*}\n\\]\n\n\n\nNow that the matrix is made, we can use the 2D to 1D conversion formula: \\((\\text{row} -1) \\times \\text{row length} + \\text{column}\\). This helps streamline the process of actually assigning what squares are adjacent to one another when a knight jumps. For every single cell, we can just calculate the knight moves with a helper function and then assign them a 1 or 0 if they are adjacent.\nThe end result looks like this:\n\n\n\n\n\n\n\n\n\nNow, the reason why we wanted to go through all this trouble was because adjacency matrices are very useful for showing future movement from any starting point. This is done as easily as just exponentiating the adjacency matrix \\(A\\) to some degree \\(n\\). In doing so, from the basic properties of matrix multiplication, which we can see clearly using the matrix \\(A\\) from before and making \\(A^2\\) and zooming in on the results of node 2:\n\\[\n\\begin{equation*}\n\\begin{gathered}\n  A =\n  \\begin{bmatrix}\n  0 & 1 & 0 & 1 \\\\\n  1 & 0 & 0 & 1 \\\\\n  0 & 0 & 0 & 1 \\\\\n  1 & 1 & 1 & 0 \\\\\n  \\end{bmatrix}\n  \\\\[1em]\n  A \\times A =\n  \\begin{bmatrix}\n  \\cdot & \\color{red}{(0 \\cdot 1) + (1 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(1 \\cdot 1) + (0 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(0 \\cdot 1) + (0 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(1 \\cdot 1) + (1 \\cdot 0) + (1 \\cdot 0) + (0 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\end{bmatrix}\n  =\n  \\begin{bmatrix}\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{2} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\end{bmatrix}\n  \\\\[1em]\n  \\begin{array}{c c l}\n    \\textbf{Start} & \\textbf{Count} & \\textbf{Explanation} \\\\\n    1 & 1 & \\text{1 path from node 1 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2: } (1 → 4 → 2) \\\\\n    2 & 2 & \\text{2 paths from node 2 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2: } (2 → 1 → 2), (2 → 4 → 2) \\\\\n    3 & 1 & \\text{1 path from node 3 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2: } (3 → 4 → 2) \\\\\n    4 & 1 & \\text{1 path from node 4 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2: } (4 → 1 → 2) \\\\\n    \\end{array}\n\\end{gathered}\n\\end{equation*}\n\\]"
  },
  {
    "objectID": "projects/madridMetro/index.html#project-overview",
    "href": "projects/madridMetro/index.html#project-overview",
    "title": "Madrid Metro MySQL Database",
    "section": "",
    "text": "Designed and implemented a MySQL database for Madrid’s metro system with detailed schema and features based on a list of assumptions, including reactive triggers and events for calculating pricing, managing metro card validity, and handling client transactions dynamically based on age, city zone, and discount eligibility."
  },
  {
    "objectID": "projects/madridMetro/index.html#system-architecture",
    "href": "projects/madridMetro/index.html#system-architecture",
    "title": "Madrid Metro MySQL Database",
    "section": "System Architecture",
    "text": "System Architecture\nRelational Schema & EER Diagram\n\nClients: stores personal info, address, and the type of discount they receive\nCards: monthly cards and rechargeable cards tied to each client\nCities: city zones and their respective pricing rules\nStatuses: discount categories (student, senior, etc.)\nCharge History: logs transactions and recharges\n\n\nRelational Schema\n\n\n\n\n\n\n\nEER Diagram"
  },
  {
    "objectID": "projects/madridMetro/index.html#key-features",
    "href": "projects/madridMetro/index.html#key-features",
    "title": "Madrid Metro MySQL Database",
    "section": "Key Features",
    "text": "Key Features\n\nDatabase Modeling\n\nNormalized schema with primary/foreign keys and cascading deletes.\nMetadata defined for all entities, ensuring referential integrity.\n\n\n\nAutomation with Triggers & Events\n\nAutomatic card issuance when registering a new client\nRecharge triggers that update validity and transaction logs\nDaily event to expire cards after 30 days without renewal\nDynamic pricing trigger calculates ticket cost based on:\n✦ Age (student/senior discounts)\n✦ City zone\n✦ Special discount status\n\n\n\nLifecycle Management\n\nFull support for registration → recharge → replacement → cancellation / expiration\nON DELETE CASCADE ensures dependent records are cleaned automatically\nAutomatic re-pricing when client address or eligibility changes"
  },
  {
    "objectID": "projects/madridMetro/index.html#code-snippet-examples",
    "href": "projects/madridMetro/index.html#code-snippet-examples",
    "title": "Madrid Metro MySQL Database",
    "section": "Code Snippet Examples",
    "text": "Code Snippet Examples\n\n1. Automatic Card Creation\nDELIMITER //\nCREATE TRIGGER makeClientMonthlyCard\nAFTER INSERT ON clients\nFOR EACH ROW\nBEGIN\n    DECLARE last_number INT;\n    DECLARE newCardID INT;\n\n    SELECT COALESCE(MAX(CardID), 0) INTO last_number FROM monthlyCard;\n    SET newCardID = last_number + 1;\n\n    INSERT INTO monthlyCard (ClientID, CardID, CardType, DateCharged, IsValid)\n    VALUES (NEW.ClientID, newCardID, \"M\", CURDATE(), 1);\nEND;//\nDELIMITER ;\nAutomatically issues a monthly card when a new client registers\n\n\n2. Automatic Recharge Handling\nDELIMITER //\nCREATE TRIGGER check_date_charged\nAFTER INSERT ON chargeHistory\nFOR EACH ROW\nBEGIN\n    UPDATE monthlyCard\n    SET DateCharged = CURDATE(), IsValid = 1\n    WHERE ClientID = NEW.ClientID;\nEND;//\nDELIMITER ;\nEnsures monthly card validity updates instantly after a recharge\n\n\n3. Daily Event to Expire Cards\nDELIMITER //\nCREATE EVENT updateValidity\nON SCHEDULE EVERY 1 DAY\nSTARTS TIMESTAMP(CURRENT_DATE + INTERVAL 1 DAY) + INTERVAL '02:30:00' HOUR_SECOND\nDO\nBEGIN\n    UPDATE monthlyCard\n    SET IsValid = 0\n    WHERE DateCharged &lt;= DATE_SUB(CURDATE(), INTERVAL 30 DAY);\nEND;//\nDELIMITER ;\nKeeps card status accurate by expiring inactive cards daily\n\n\n4. Dynamic Pricing Based on Age, Zone, and Circumstance\nDELIMITER //\nCREATE TRIGGER calculatePrice\nBEFORE INSERT ON clients\nFOR EACH ROW\nBEGIN\n    DECLARE client_age INT;\n    DECLARE client_discount DECIMAL(10,2);\n    DECLARE final_price DECIMAL(10,2);\n    DECLARE zone_price DECIMAL(10,2);\n    DECLARE ifStudent BOOLEAN;\n    DECLARE ifZoneA BOOLEAN;\n\n    SET client_age = TIMESTAMPDIFF(YEAR, NEW.BDay, CURDATE());\n\n    -- Apply senior discount when turning 65\n    IF client_age &gt;= 65 THEN\n        SET NEW.discountType = CONCAT(SUBSTRING(NEW.discountType, 1, CHAR_LENGTH(NEW.discountType) - 1), 'M');\n    END IF;\n\n    SELECT statuses.discountAmount INTO client_discount\n      FROM statuses WHERE statuses.typeID = NEW.discountType;\n\n    IF NEW.discountType LIKE 'E%' THEN \n      SET ifStudent = 1; \n      ELSE SET ifStudent = 0; \n    END IF;\n    \n    SELECT ZonePrice INTO zone_price FROM cities WHERE CityName = NEW.City;\n    \n    SELECT EXISTS(\n        SELECT 1 FROM clients\n        WHERE PostalCode LIKE '280%' AND ClientID = NEW.ClientID\n    ) INTO ifZoneA;\n\n    IF ifStudent = 1 AND client_age &gt;= 65 THEN\n        SET final_price = 6.30 * client_discount;\n    ELSEIF client_age &lt; 26 OR ifStudent = 1 THEN\n        SET final_price = 20.00 * client_discount;\n    ELSEIF client_age &gt;= 65 THEN\n        SET final_price = 6.30 * client_discount;\n    ELSEIF ifZoneA = 1 THEN\n        SET final_price = 54.60 * client_discount;\n    ELSE\n        SET final_price = zone_price * client_discount;\n    END IF;\n\n    INSERT INTO chargeHistory (ClientID, ChargeAmount, Type) \n    VALUES (NEW.ClientID, final_price, \"Purchase\");\nEND;//\nDELIMITER ;\nDetermines ticket cost dynamically based on multiple client attributes"
  },
  {
    "objectID": "projects/madridMetro/index.html#example-queries",
    "href": "projects/madridMetro/index.html#example-queries",
    "title": "Madrid Metro MySQL Database",
    "section": "Example Queries",
    "text": "Example Queries\n-- Show all clients in Leganés with zone category and purchase price\nSELECT clients.*, cities.ZoneID, chargeHistory.ChargeAmount\n  FROM clients\n  INNER JOIN cities ON clients.City = cities.CityName\n  INNER JOIN chargeHistory ON clients.ClientID = chargeHistory.ClientID\n  WHERE clients.City = 'Leganes';\n-- Check validity of a specific client’s card\nSELECT ClientID, isValid \n  FROM monthlyCard\n  WHERE ClientID = \"002\";"
  },
  {
    "objectID": "projects/madridMetro/index.html#technical-highlights",
    "href": "projects/madridMetro/index.html#technical-highlights",
    "title": "Madrid Metro MySQL Database",
    "section": "Technical Highlights",
    "text": "Technical Highlights\n\nSQL: DDL, DML, joins, triggers, events, cascading constraints\nRelational schema design with 1:1 and 1:M relationships\nBusiness rules automation embedded directly in the database\nData integrity & lifecycle tracking across multiple entities"
  },
  {
    "objectID": "projects/madridMetro/index.html#portfolio-value",
    "href": "projects/madridMetro/index.html#portfolio-value",
    "title": "Madrid Metro MySQL Database",
    "section": "Portfolio Value",
    "text": "Portfolio Value\nThis project demonstrates my ability to: - Design real-world relational databases - Implement automated business logic inside SQL - Manage complex client workflows in a high-traffic system\n\nSkills Demonstrated: MySQL · Relational Database Design · SQL Triggers & Events · Data Lifecycle Management · Business Rules Implementation"
  },
  {
    "objectID": "projects/madridMetro/index.html#skills",
    "href": "projects/madridMetro/index.html#skills",
    "title": "Madrid Metro MySQL Database",
    "section": "Skills",
    "text": "Skills\nThis project demonstrates my ability to: - Design real-world relational databases - Implement automated logic based on given assumptions inside SQL - Manage complex client workflows in a high-traffic system\n\nSkills Demonstrated: MySQL · Relational Database Design · SQL Triggers & Events · Data Lifecycle Management"
  },
  {
    "objectID": "projects/NonProfitMapper/index.html",
    "href": "projects/NonProfitMapper/index.html",
    "title": "Nonprofit Leaflet",
    "section": "",
    "text": "Nonprofit Mapper"
  },
  {
    "objectID": "projects/LonelinessProject/index.html",
    "href": "projects/LonelinessProject/index.html",
    "title": "Loneliness Project",
    "section": "",
    "text": "This project started as a project as part of the course, “Language in Social Media: A Computational Linguistics Perspective” taught by Zuoyu Tian, who was a great source of support in this project. The group consisted of Elan Levin, Sylvain Zong-Nabia, and myself. I went on individually to expand on the project and refine some of the aspects we didn’t have time to address due to our heavy workloads in the final months of university.\n\n\nOur data came from when we were conducting a literature review of loneliness of social media to find a gap in the literature to explore.\nhttps://huggingface.co/datasets/FIG-Loneliness/FIG-Loneliness\n\n\n\nJiang, Y., Jiang, Y., Leqi, L., & Winkielman, P. (2022). Many Ways to Be Lonely: Fine-Grained Characterization of Loneliness and Its Potential Changes in COVID-19. Proceedings of the International AAAI Conference on Web and Social Media, 16(1), 405-416. Retrieved from https://ojs.aaai.org/index.php/ICWSM/article/view/19302"
  },
  {
    "objectID": "projects/LonelinessProject/index.html#data-acquisition",
    "href": "projects/LonelinessProject/index.html#data-acquisition",
    "title": "Loneliness Project",
    "section": "",
    "text": "Our data came from when we were conducting a literature review of loneliness of social media to find a gap in the literature to explore.\nhttps://huggingface.co/datasets/FIG-Loneliness/FIG-Loneliness"
  },
  {
    "objectID": "projects/LonelinessProject/index.html#bibliography",
    "href": "projects/LonelinessProject/index.html#bibliography",
    "title": "Loneliness Project",
    "section": "",
    "text": "Jiang, Y., Jiang, Y., Leqi, L., & Winkielman, P. (2022). Many Ways to Be Lonely: Fine-Grained Characterization of Loneliness and Its Potential Changes in COVID-19. Proceedings of the International AAAI Conference on Web and Social Media, 16(1), 405-416. Retrieved from https://ojs.aaai.org/index.php/ICWSM/article/view/19302"
  },
  {
    "objectID": "projects/KnightTourVisual/app.html#the-math-behind-the-app",
    "href": "projects/KnightTourVisual/app.html#the-math-behind-the-app",
    "title": "Knight’s Tour Adjacency Matrix Visual",
    "section": "The Math Behind the App",
    "text": "The Math Behind the App\n\nAdjacency Matrices\nAn adjacency matrix is a type of matrix used to represent a mathematical graph, as pictured below:\n\n\n\n\n\nThe matrix shows which vertices are adjacent to one another and which are not. It can be thought of as this: rows are the starting points and the columns are the ending points. If you can get from a starting point to an ending point, then a 1 is placed, and a 0 is placed if not.\n\\[\nA =\n\\begin{bmatrix}\n0 & 1 & 0 & 1 \\\\\n1 & 0 & 0 & 1 \\\\\n0 & 0 & 0 & 1 \\\\\n1 & 1 & 1 & 0 \\\\\n\\end{bmatrix}\n\\]\nFor example, in our graph, 2 and 4 are connected, so if you look in the 2nd row (the starting place) and then look at the 4th row (the ending place), you will see that there is a 1. Vice versa, if you look at \\(A_{2,3}\\) you will see that it is a 0, meaning 2 and 3 are unconnected, which can be confirmed from looking at the graph. These types of matrices are always square \\(n \\times n\\) matrices because it just the same vertices being shown in the both and rows and columns. How this relates to a knight is if you imagine the 64 squares on a chess board as vertices, we can graph the connecting vertices to show what the knight can make in one move (later on we will be able to show multiple moves, but we are not there yet).\nHowever, chess squares have defined places where they are. In this graph, 1 can be put to the right of 4 and it wouldn’t matter, as seen below.\n\n\n\n\n\n\n\nThere is not difference between this graph and the one before, it will have the same adjacency matrix\n\n\n\n\nLattice Adjacency Matrices\nWe need to introduce a system of order to the graph to make it more of a rigid grid. This is precisely why using a Lattice graph is so helpful in this case. Lattice graphs offer distinct coordinates, or lattices, which line up exactly with what we want to do with the chess squares because each squares is distinct and has 2-dimensional coordinates (i.e. the point (1,2) has an x dimension and a y dimension).\n\\[\n\\begin{gather*}\n\\begin{bmatrix}\n(1,1) & (1,2) & (1,3) \\\\\n(2,1) & (2,2) & (2,3) \\\\\n(3,1) & (3,2) & (3,3) \\\\\n\\end{bmatrix} \\\\\n\\text{Lattice Matrix}\n\\end{gather*}\n\\]\nJust as we made a adjacency matrix out of a normal graph, we can make a lattice adjacency matrix out of a lattice graph. For our purposes, lattice matrices are just regular matrices, but each entry in the matrix is representative of a lattice point (i.e. \\(A_{1,1} \\text{ is representative of the lattice point } (1,1)\\)).\nIn order to make a lattice adjacency matrix given \\(n \\times n\\) lattices, we will essentially construct a \\(n^2 \\times n^2\\) matrix. This comes from exactly what we did with the adjacency matrices; every single node was put across horizontally and vertically in order to have every pairs of connections between the nodes. Just in this case, since our grid has \\(n \\times n = n^2\\) lattices, it will be much larger. Essentially what we’re doing is making a long vector out of the lattice and then making that long vector 2D by taking the outer-product of 2 of long vectors.\n\\[\n\\begin{gather*}\n  \\begin{bmatrix}\n  1 & 2 & 3 \\\\\n  4 & 5 & 6 \\\\\n  7 & 8 & 9 \\\\\n  \\end{bmatrix}\n  \\longrightarrow\n  \\begin{bmatrix}\n  1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ 6 \\\\ 7 \\\\ 8 \\\\ 9 \\\\ \\end{bmatrix}\n  \\longrightarrow\n  \\begin{bmatrix}\n  &1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\\\\n  1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ 6 \\\\ 7 \\\\ 8 \\\\ 9 \\\\\n  \\end{bmatrix} \\\\\n  \\space\\space\\text{Lattice}\\space\\space\\space\\space\\space\\space\\space\\text{Long Vector}\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\text{2D Long Vector}\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space\n\\end{gather*}\n\\]\n\n\nMaking the Lattice Adjacency Matrix\nNow that the matrix is made, we can use the 2D to 1D conversion formula: \\((\\text{row} -1) \\times \\text{row length} + \\text{column}\\). This helps streamline the process of actually assigning what squares are adjacent to one another when a knight jumps. For every single cell, we can just calculate the knight moves with a helper function and then assign them a 1 or 0 if they are adjacent.\nThe end result looks like this:\n\n\n\n\n\n\n\n\n\nNow, the reason why we wanted to go through all this trouble was because adjacency matrices are very useful for showing future movement from any starting point. This is done as easily as just exponentiating the adjacency matrix \\(A\\) to some degree \\(n\\). In doing so, from the basic properties of matrix multiplication, which we can see clearly using the matrix \\(A\\) from before and making \\(A^2\\) and zooming in on the results of node 2:\n\\[\n\\begin{equation*}\n\\begin{gathered}\n  A =\n  \\begin{bmatrix}\n  0 & 1 & 0 & 1 \\\\\n  1 & 0 & 0 & 1 \\\\\n  0 & 0 & 0 & 1 \\\\\n  1 & 1 & 1 & 0 \\\\\n  \\end{bmatrix}\n  \\\\[1em]\n  A \\times A =\n  \\begin{bmatrix}\n  \\cdot & \\color{red}{(0 \\cdot 1) + (1 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(1 \\cdot 1) + (0 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(0 \\cdot 1) + (0 \\cdot 0) + (0 \\cdot 0) + (1 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{(1 \\cdot 1) + (1 \\cdot 0) + (1 \\cdot 0) + (0 \\cdot 1)} & \\cdot & \\cdot \\\\\n  \\end{bmatrix}\n  =\n  \\begin{bmatrix}\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{2} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\cdot & \\color{red}{1} & \\cdot & \\cdot \\\\\n  \\end{bmatrix}\n  \\\\[1em]\n  \\begin{array}{c c l}\n    \\textbf{Start} & \\textbf{Count} & \\textbf{Explanation} \\\\\n    1 & 1 & \\text{1 path from node 1 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2: } (1 → 4 → 2) \\\\\n    2 & 2 & \\text{2 paths from node 2 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2: } (2 → 1 → 2), (2 → 4 → 2) \\\\\n    3 & 1 & \\text{1 path from node 3 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2: } (3 → 4 → 2) \\\\\n    4 & 1 & \\text{1 path from node 4 of } \\textcolor{green}{\\text{length }\\textbf{2}} \\text{ to node 2: } (4 → 1 → 2) \\\\\n    \\end{array}\n\\end{gathered}\n\\end{equation*}\n\\]"
  },
  {
    "objectID": "cv.html",
    "href": "cv.html",
    "title": "Curriculum Vitae",
    "section": "",
    "text": "Download Resume (PDF)"
  }
]