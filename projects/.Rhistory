observe({
inactivityTimer()  # Trigger every 3s
isolate({
if (difftime(Sys.time(), lastActivity(), units = "secs") >= 3) {
autoAnimate(TRUE)
} else {
autoAnimate(FALSE)
}
})
})
# === Increment exponent every 2 seconds if animating ===
observe({
req(autoAnimate())
isolate({
current <- input$exponent
if (current < 25) {
updateSliderInput(session, "exponent", value = current + 1)
} else {
updateSliderInput(session, "exponent", value = 1)
}
})
invalidateLater(2000, session)  # 2 second delay
})
# === Update knight position on click ===
observeEvent(input$plot_click, {
click <- input$plot_click
x <- max(min(round(click$x), input$cols), 1)
y <- max(min(round(click$y), input$rows), 1)
pos(c(y, x))
text("")
})
# === Keep position within bounds ===
observeEvent(input$rows, {
current_pos <- pos()
if (current_pos[1] > input$rows) pos(c(input$rows, current_pos[2]))
})
observeEvent(input$cols, {
current_pos <- pos()
if (current_pos[2] > input$cols) pos(c(current_pos[1], input$cols))
})
# === Render plot and text ===
output$textBox <- renderText({ text() })
output$knightPlot <- renderPlot({
plotKnightFromMatrix(position = pos(),
nrows = input$rows,
ncols = input$cols,
exponent = input$exponent,
showPathsToExponent = as.logical(input$showPaths),
probability = as.logical(input$mode))
}, height = 650, width = 650)
}
# Run the application
shinyApp(ui = ui, server = server)
ui <- fluidPage(
sidebarLayout( # all of the input bars
sidebarPanel(
sliderInput("exponent", # id
label = "Choose # of Moves Made",
min = 1,
max = 25,
value = 1,
step = 1),
sliderInput("rows",
label = "# of Rows",
min = 2,
max = 8,
value = 8,
step = 1),
sliderInput("cols",
label = "# of Columns",
min = 2,
max = 8,
value = 8,
step = 1),
radioButtons("showPaths",
label = "Show pathing squares?",
choices = list("Yes" = TRUE, "No" = FALSE),
selected = TRUE),
radioButtons("mode", # make probability of count
label = "Mode",
choices = list("Count" = FALSE, "Probability" = TRUE),
selected = FALSE),
div(
style = "font-size: 24px; font-weight: bold; margin-top: 20px;",
textOutput("textBox")
)
),
mainPanel(
plotOutput("knightPlot", click = "plot_click", width = "100%")
)
)
)
# Server logic to receive inputs
server <- function(input, output, session) {
pos <- reactiveVal(c(5, 5))
text <- reactiveVal("Click any tile to move the knight")
# === Reactive value to track last activity time ===
lastActivity <- reactiveVal(Sys.time())
# === Reactive trigger for inactivity ===
inactivityTimer <- reactiveTimer(1000)  # 3 seconds
# === Observe all inputs for activity ===
observeEvent(
list(input$exponent, input$plot_click, input$rows, input$cols, input$showPaths, input$mode),
{
lastActivity(Sys.time())  # Reset activity
}
)
# === Auto animation logic ===
autoAnimate <- reactiveVal(FALSE)
observe({
inactivityTimer()  # Trigger every 3s
isolate({
if (difftime(Sys.time(), lastActivity(), units = "secs") >= 3) {
autoAnimate(TRUE)
} else {
autoAnimate(FALSE)
}
})
})
# === Increment exponent every 2 seconds if animating ===
observe({
req(autoAnimate())
isolate({
current <- input$exponent
if (current < 25) {
updateSliderInput(session, "exponent", value = current + 1)
} else {
updateSliderInput(session, "exponent", value = 1)
}
})
invalidateLater(2000, session)  # 2 second delay
})
# === Update knight position on click ===
observeEvent(input$plot_click, {
click <- input$plot_click
x <- max(min(round(click$x), input$cols), 1)
y <- max(min(round(click$y), input$rows), 1)
pos(c(y, x))
text("")
})
# === Keep position within bounds ===
observeEvent(input$rows, {
current_pos <- pos()
if (current_pos[1] > input$rows) pos(c(input$rows, current_pos[2]))
})
observeEvent(input$cols, {
current_pos <- pos()
if (current_pos[2] > input$cols) pos(c(current_pos[1], input$cols))
})
# === Render plot and text ===
output$textBox <- renderText({ text() })
output$knightPlot <- renderPlot({
plotKnightFromMatrix(position = pos(),
nrows = input$rows,
ncols = input$cols,
exponent = input$exponent,
showPathsToExponent = as.logical(input$showPaths),
probability = as.logical(input$mode))
}, height = 650, width = 650)
}
# Run the application
shinyApp(ui = ui, server = server)
ui <- fluidPage(
sidebarLayout( # all of the input bars
sidebarPanel(
sliderInput("exponent", # id
label = "Choose # of Moves Made",
min = 1,
max = 25,
value = 1,
step = 1),
sliderInput("rows",
label = "# of Rows",
min = 2,
max = 8,
value = 8,
step = 1),
sliderInput("cols",
label = "# of Columns",
min = 2,
max = 8,
value = 8,
step = 1),
radioButtons("showPaths",
label = "Show pathing squares?",
choices = list("Yes" = TRUE, "No" = FALSE),
selected = TRUE),
radioButtons("mode", # make probability of count
label = "Mode",
choices = list("Count" = FALSE, "Probability" = TRUE),
selected = FALSE),
div(
style = "font-size: 24px; font-weight: bold; margin-top: 20px;",
textOutput("textBox")
)
),
mainPanel(
plotOutput("knightPlot", click = "plot_click", width = "100%")
)
)
)
# Server logic to receive inputs
server <- function(input, output, session) {
pos <- reactiveVal(c(5, 5))
text <- reactiveVal("Click any tile to move the knight")
# === Reactive value to track last activity time ===
lastActivity <- reactiveVal(Sys.time())
# === Reactive trigger for inactivity ===
inactivityTimer <- reactiveTimer(500)  # 3 seconds
# === Observe all inputs for activity ===
observeEvent(
list(input$exponent, input$plot_click, input$rows, input$cols, input$showPaths, input$mode),
{
lastActivity(Sys.time())  # Reset activity
}
)
# === Auto animation logic ===
autoAnimate <- reactiveVal(FALSE)
observe({
inactivityTimer()  # Trigger every 3s
isolate({
if (difftime(Sys.time(), lastActivity(), units = "secs") >= 3) {
autoAnimate(TRUE)
} else {
autoAnimate(FALSE)
}
})
})
# === Increment exponent every 2 seconds if animating ===
observe({
req(autoAnimate())
isolate({
current <- input$exponent
if (current < 25) {
updateSliderInput(session, "exponent", value = current + 1)
} else {
updateSliderInput(session, "exponent", value = 1)
}
})
invalidateLater(2000, session)  # 2 second delay
})
# === Update knight position on click ===
observeEvent(input$plot_click, {
click <- input$plot_click
x <- max(min(round(click$x), input$cols), 1)
y <- max(min(round(click$y), input$rows), 1)
pos(c(y, x))
text("")
})
# === Keep position within bounds ===
observeEvent(input$rows, {
current_pos <- pos()
if (current_pos[1] > input$rows) pos(c(input$rows, current_pos[2]))
})
observeEvent(input$cols, {
current_pos <- pos()
if (current_pos[2] > input$cols) pos(c(current_pos[1], input$cols))
})
# === Render plot and text ===
output$textBox <- renderText({ text() })
output$knightPlot <- renderPlot({
plotKnightFromMatrix(position = pos(),
nrows = input$rows,
ncols = input$cols,
exponent = input$exponent,
showPathsToExponent = as.logical(input$showPaths),
probability = as.logical(input$mode))
}, height = 650, width = 650)
}
# Run the application
shinyApp(ui = ui, server = server)
ui <- fluidPage(
sidebarLayout( # all of the input bars
sidebarPanel(
sliderInput("exponent", # id
label = "Choose # of Moves Made",
min = 1,
max = 25,
value = 1,
step = 1),
sliderInput("rows",
label = "# of Rows",
min = 2,
max = 8,
value = 8,
step = 1),
sliderInput("cols",
label = "# of Columns",
min = 2,
max = 8,
value = 8,
step = 1),
radioButtons("showPaths",
label = "Show pathing squares?",
choices = list("Yes" = TRUE, "No" = FALSE),
selected = TRUE),
radioButtons("mode", # make probability of count
label = "Mode",
choices = list("Count" = FALSE, "Probability" = TRUE),
selected = FALSE),
div(
style = "font-size: 24px; font-weight: bold; margin-top: 20px;",
textOutput("textBox")
)
),
mainPanel(
plotOutput("knightPlot", click = "plot_click", width = "100%")
)
)
)
# Server logic to receive inputs
server <- function(input, output, session) {
pos <- reactiveVal(c(5, 5))
text <- reactiveVal("Click any tile to move the knight")
# === Reactive value to track last activity time ===
lastActivity <- reactiveVal(Sys.time())
# === Reactive trigger for inactivity ===
inactivityTimer <- reactiveTimer(500)  # 3 seconds
# === Observe all inputs for activity ===
observeEvent(
list(input$exponent, input$plot_click, input$rows, input$cols, input$showPaths, input$mode),
{
lastActivity(Sys.time())  # Reset activity
}
)
# === Auto animation logic ===
autoAnimate <- reactiveVal(FALSE)
observe({
inactivityTimer()  # Trigger every 3s
isolate({
if (difftime(Sys.time(), lastActivity(), units = "secs") >= 3) {
autoAnimate(TRUE)
} else {
autoAnimate(FALSE)
}
})
})
# === Increment exponent every 2 seconds if animating ===
observe({
req(autoAnimate())
isolate({
current <- input$exponent
if (current < 25) {
updateSliderInput(session, "exponent", value = current + 1)
} else {
updateSliderInput(session, "exponent", value = 1)
}
})
invalidateLater(2000, session)  # 2 second delay
})
# === Update knight position on click ===
observeEvent(input$plot_click, {
click <- input$plot_click
x <- max(min(round(click$x), input$cols), 1)
y <- max(min(round(click$y), input$rows), 1)
pos(c(y, x))
text("")
})
# === Keep position within bounds ===
observeEvent(input$rows, {
current_pos <- pos()
if (current_pos[1] > input$rows) pos(c(input$rows, current_pos[2]))
})
observeEvent(input$cols, {
current_pos <- pos()
if (current_pos[2] > input$cols) pos(c(current_pos[1], input$cols))
})
# === Render plot and text ===
output$textBox <- renderText({ text() })
output$knightPlot <- renderPlot({
plotKnightFromMatrix(position = pos(),
nrows = input$rows,
ncols = input$cols,
exponent = input$exponent,
showPathsToExponent = as.logical(input$showPaths),
probability = as.logical(input$mode))
}, height = 650, width = 650)
}
# Run the application
shinyApp(ui = ui, server = server)
ui <- fluidPage(
sidebarLayout( # all of the input bars
sidebarPanel(
sliderInput("exponent", # id
label = "Choose # of Moves Made",
min = 1,
max = 25,
value = 1,
step = 1),
sliderInput("rows",
label = "# of Rows",
min = 2,
max = 8,
value = 8,
step = 1),
sliderInput("cols",
label = "# of Columns",
min = 2,
max = 8,
value = 8,
step = 1),
radioButtons("showPaths",
label = "Show pathing squares?",
choices = list("Yes" = TRUE, "No" = FALSE),
selected = TRUE),
radioButtons("mode", # make probability of count
label = "Mode",
choices = list("Count" = FALSE, "Probability" = TRUE),
selected = FALSE),
div(
style = "font-size: 24px; font-weight: bold; margin-top: 20px;",
textOutput("textBox")
)
),
mainPanel(
plotOutput("knightPlot", click = "plot_click", width = "100%")
)
)
)
# Server logic to receive inputs
server <- function(input, output, session) {
pos <- reactiveVal(c(5, 5))
text <- reactiveVal("Click any tile to move the knight")
# === Reactive value to track last activity time ===
lastActivity <- reactiveVal(Sys.time())
# === Reactive trigger for inactivity ===
inactivityTimer <- reactiveTimer(500)  # 3 seconds
# === Observe all inputs for activity ===
observeEvent(
list(input$exponent, input$plot_click, input$rows, input$cols, input$showPaths, input$mode),
{
lastActivity(Sys.time())  # Reset activity
}
)
# === Auto animation logic ===
autoAnimate <- reactiveVal(FALSE)
observe({
inactivityTimer()  # Trigger every 3s
isolate({
if (difftime(Sys.time(), lastActivity(), units = "secs") >= 3) {
autoAnimate(TRUE)
} else {
autoAnimate(FALSE)
}
})
})
# === Increment exponent every 2 seconds if animating ===
observe({
req(autoAnimate())
isolate({
current <- input$exponent
if (current < 25) {
updateSliderInput(session, "exponent", value = current + 1)
} else {
updateSliderInput(session, "exponent", value = 1)
}
})
invalidateLater(2000, session)  # 2 second delay
})
# === Update knight position on click ===
observeEvent(input$plot_click, {
click <- input$plot_click
x <- max(min(round(click$x), input$cols), 1)
y <- max(min(round(click$y), input$rows), 1)
pos(c(y, x))
text("")
})
# === Keep position within bounds ===
observeEvent(input$rows, {
current_pos <- pos()
if (current_pos[1] > input$rows) pos(c(input$rows, current_pos[2]))
})
observeEvent(input$cols, {
current_pos <- pos()
if (current_pos[2] > input$cols) pos(c(current_pos[1], input$cols))
})
# === Render plot and text ===
output$textBox <- renderText({ text() })
output$knightPlot <- renderPlot({
plotKnightFromMatrix(position = pos(),
nrows = input$rows,
ncols = input$cols,
exponent = input$exponent,
showPathsToExponent = as.logical(input$showPaths),
probability = as.logical(input$mode))
}, height = 650, width = 650)
}
# Run the application
shinyApp(ui = ui, server = server)
library(ggplot2)
library(tidyverse)
library(Matrix)
library(purrr)
library(expm)
library(grid)
library(ggplot2)
library(stringr)
library(shiny)
library(rsconnect)
install.packages("rsconnect")
library(tidyverse)
library(Matrix)
library(purrr)
library(expm)
library(grid)
library(ggplot2)
library(stringr)
library(shiny)
library(rsconnect)
'%notin%' <- Negate('%in%')
rsconnect::setAccountInfo(name='miles-libbey', token='BAD34BCD1A078D34101A3C52F85CE8CA', secret='TbJkz3mq3u9jcwM6j+5a+eNkeXDQuQzCGKzkhJ1q')
setwd("~/Desktop/milesLV.github.io/projects")
